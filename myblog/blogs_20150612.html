        		<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='zh-CN' xml:lang='zh-CN' xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <meta http-equiv="Content-Language" content="zh-CN"/>
  <title>robin-yao的博客</title>
  <style>
  body {font:12px/21px Tahoma,"Microsoft Yahei",Geneva,sans-serif;}
  h1 a {color:#40AA53;}
  h1 a,h2 a{text-decoration:none;}
  .backupDesc em {font-style:normal;}
  .blog {margin:0 0 20px 0;border:1px solid #ccc;background:#ffc;padding:10px;}
  .blog h2 {border-bottom:1px solid #ccc;padding:0 0 10px 0;}
  .blog h2 a.top {float:right;font-weight:normal;font-size:9pt;}
  .blog .outline {background:#fff;border:1px solid #eee;padding:10px;color:#666;}
  
  .commentList {margin:20px 0 0 0;}
  .comment {margin:0 0 10px 0; border:1px solid #ddd; background:#ffe;padding:5px;}
  .comment .author {float:left;font-weight:bold;}
  .comment .date {float:left;margin:0 0 0 10px;}
  .comment .content {clear:left;margin:5px 0 0 0;}
  </style>
</head>
<body>
  <h1><a name='top' href="http://my.oschina.net/robinyao/blog">robin-yao的博客@OSCHINA</a></h1>
  <p class='backupDesc'>共有<em>20</em>篇文章，备份时间：2015-06-12 23:13:08</p>
  <ol>
		<li><a href="#blog_425014">mongodb建立索引遇到的坑</a></li>
		<li><a href="#blog_423036">Dokcerfile Instructions</a></li>
		<li><a href="#blog_418953">单元测试覆盖率-maven插件-jacoco</a></li>
		<li><a href="#blog_415934">Storm Tutorial</a></li>
		<li><a href="#blog_415757">Storm 0.9 集群搭建</a></li>
		<li><a href="#blog_410048">统计Redis中各种数据大小</a></li>
		<li><a href="#blog_409153">编写maven插件介绍</a></li>
		<li><a href="#blog_408285">BenchMark工具-JMH介绍</a></li>
		<li><a href="#blog_407469">Netty ByteBuf详解</a></li>
		<li><a href="#blog_406544">Jetty源码-Continuation</a></li>
		<li><a href="#blog_404687">Jetty源码-Server-Connector</a></li>
		<li><a href="#blog_403615">Jetty源码-IO-ManagedSelector</a></li>
		<li><a href="#blog_403334">Jetty源码-IO-BufferBufferPool</a></li>
		<li><a href="#blog_403215">zookeeper Leader Elections</a></li>
		<li><a href="#blog_402692">Jetty源码-IO-BufferUtil</a></li>
		<li><a href="#blog_402068">shell编写图片爬虫</a></li>
		<li><a href="#blog_400712">Jetty源码-自旋锁的实现</a></li>
		<li><a href="#blog_399164">Maven依赖jar包冲突常见的解决方法</a></li>
		<li><a href="#blog_399060">Netty实现服务端客户端长连接通讯及心跳检测</a></li>
		<li><a href="#blog_398808">利用Redis BitMap 统计用户活跃指标</a></li>
	  </ol>
  <div class='blogList'>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_425014" href="http://my.oschina.net/robinyao/blog/425014">mongodb建立索引遇到的坑</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-06-04 20:44:10</div>
	  <div class='catalog'>分类：nosql</div>
	  	  	  <div class='tags'>标签：nosql,mongodb</div>	  	  	  </div>
      <div class='content'><p>&nbsp; &nbsp; &nbsp; &nbsp;最近为线上的mongodb建立索引。当时mongodb单collection存有大约1亿条记录，在建立索引过程中发现程序报警，mongodb写入超时，不能及时消费MQ中的消息。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;当时心里想肯定是建索引的过程较慢，阻塞mongodb的读写请求。直接查了一下资料，mongodb 文档 如下：</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<span style="font-size: 14px; font-family: 'arial black', 'avant garde';">By default, creating an index blocks all other operations on a database. When building an index on a collection, the database that holds the collection is unavailable for read or write operations until the index build completes. Any operation that requires a read or write lock on all databases (e.g. listDatabases) will wait for the foreground index build to complete.</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp; mongodb 建立索引默认是阻塞该集合上的读写操作，只有指定background 才会在后台建立索引，恰好与个人的直觉相反，感觉挺坑。如果想在后台建立索引可以 如下面这样<br></p><pre class="brush:java;toolbar: true; auto-links: false;">db.people.createIndex(&nbsp;{&nbsp;zipcode:&nbsp;1},&nbsp;{background:&nbsp;true}&nbsp;)</pre><p></p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;另外mongodb 出现问题时可以借助 mongostat 来查看mongodb的状态，例如每秒的读写次数等等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当时用mongostat连接不上去mongodb。只好通过mongodb的log来查看mongodb的状态。通过mongodb的log可以看到mongodb建立索引的过程进度。当初多亏看到这个进度才没有重新启动mongodb,所否可能中途直接杀死mongodb，mongodb会画更多时间来恢复，也有可能起不来（只是猜想）。<br></p><p><br></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_423036" href="http://my.oschina.net/robinyao/blog/423036">Dokcerfile Instructions</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-05-31 15:45:00</div>
	  <div class='catalog'>分类：docker</div>
	  	  	  <div class='tags'>标签：DOCKER,Dockerfile,容器</div>	  	  	  </div>
      <div class='content'><h2>FROM</h2><pre class="prettyprint well">FROM&nbsp;&lt;image&gt;</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">Or</p><pre class="prettyprint well">FROM&nbsp;&lt;image&gt;:&lt;tag&gt;</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">Or</p><pre class="prettyprint well">FROM&nbsp;&lt;image&gt;@&lt;digest&gt;</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;FROM 指令为随下的指令设置 Base Image 。一个有效的Dockerfile一般必须以FROM 开始作为它的第一个指令。 Image 可是是任意有效的镜像。<br></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;tar &nbsp;或者 digest 是可选的，如果忽略默认是 latest。</p><p style="margin-top: 0px; margin-bottom: 1em; color: rgb(57, 77, 84); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><span style="font-size: 21px; line-height: 1.7;">MAINTAINER</span><br></p><pre class="prettyprint well">MAINTAINER&nbsp;&lt;name&gt;</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;该指令允许你添加一些作者的信息。</p><h2>RUN</h2><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp; &nbsp; RUN 有两种形式：shell form 与 exec form</p><ul><li><p><code>RUN &lt;command&gt;</code>&nbsp;(the command is run in a shell -&nbsp;<code>/bin/sh -c</code>&nbsp;-&nbsp;<em>shell</em>&nbsp;form)</p></li><li><p><code>RUN ["executable", "param1", "param2"]</code>&nbsp;(<em>exec</em>&nbsp;form)</p><p><br></p></li></ul><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">RUN &nbsp;指令 在当前镜像上可以执行任何命令，并提交结果。</p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><br></p><h2>CMD</h2><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">CMD 指令有三种形式：</p><ul><li><p><code>CMD ["executable","param1","param2"]</code>&nbsp;(<em>exec</em>&nbsp;form, this is the preferred form)</p></li><li><p><code>CMD ["param1","param2"]</code>&nbsp;(as&nbsp;<em>default parameters to ENTRYPOINT</em>)</p></li><li><p><code>CMD command param1 param2</code>&nbsp;(<em>shell</em>&nbsp;form)</p></li></ul><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">一个Dockerfile中 只能有一个CMD指令。如果有多个CMD，只有最后一个CMD指令生效</p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">CMD的主要目的是为正在执行的容器提高默认的执行。与<code>ENTRYPOINT指令类似。</code></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><span style="font-size: 24px; font-weight: 600; font-family: 微软雅黑, Verdana, sans-serif, 宋体;">LABEL</span><br></p><pre class="prettyprint well">LABEL&nbsp;&lt;key&gt;=&lt;value&gt;&nbsp;&lt;key&gt;=&lt;value&gt;&nbsp;&lt;key&gt;=&lt;value&gt;&nbsp;...</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">LABEL指令为镜像添加元信息。LABEL以键值对的形式出现。</p><pre class="prettyprint well">LABEL&nbsp;"com.example.vendor"="ACME&nbsp;Incorporated"</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><br></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">一个镜像可以包含多个LABEL键值对</p><pre class="prettyprint well">LABEL&nbsp;com.example.label-without-value
LABEL&nbsp;com.example.label-with-value="foo"LABEL&nbsp;version="1.0"LABEL&nbsp;description="This&nbsp;text&nbsp;illustrates&nbsp;\
that&nbsp;label-values&nbsp;can&nbsp;span&nbsp;multiple&nbsp;lines."</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp; 浏览一个镜像的labels，可以用docker inspect 命令</p><h2>EXPOSE</h2><pre class="prettyprint well">EXPOSE&nbsp;&lt;port&gt;&nbsp;[&lt;port&gt;...]</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><br></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">EXPOSE 指令通知Docker容器运行时将监听指定的网络端口。Docker 将利用该信息与容器连接并决定将哪些端口暴露给主机。</p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><br></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><span style="font-size: 24px; font-weight: 600; font-family: 微软雅黑, Verdana, sans-serif, 宋体;">ENV</span><br></p><pre class="prettyprint well">ENV&nbsp;&lt;key&gt;&nbsp;&lt;value&gt;ENV&nbsp;&lt;key&gt;=&lt;value&gt;&nbsp;...</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">ENV指令通过键值对形式设定环境变量。</p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; white-space: normal; background-color: rgb(255, 255, 255);"><code><span style="font-family:Helvetica Neue, Helvetica, Arial, sans-serif">&nbsp;ENV</span></code><span style="font-family:Helvetica Neue, Helvetica, Arial, sans-serif">&nbsp;指令有两种形式：&nbsp;</span></p><pre class="prettyprint well">ENV&nbsp;myName="John&nbsp;Doe"&nbsp;myDog=Rex\&nbsp;The\&nbsp;Dog&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;myCat=fluffy</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">and</p><pre class="prettyprint well">ENV&nbsp;myName&nbsp;John&nbsp;DoeENV&nbsp;myDog&nbsp;Rex&nbsp;The&nbsp;DogENV&nbsp;myCat&nbsp;fluffy</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><br></p><h2>ADD</h2><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">ADD 有两种形式:</p><ul><li><p><code>ADD &lt;src&gt;... &lt;dest&gt;</code></p></li><li><p><code>ADD ["&lt;src&gt;"... "&lt;dest&gt;"]</code>&nbsp;(this form is required for paths containing whitespace)</p></li></ul><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">ADD指令从src中copy 内容到当前容器的文件系统中。</p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><span style="font-size: 24px; font-weight: 600; font-family: 微软雅黑, Verdana, sans-serif, 宋体;">COPY</span></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">COPY <span style="color: rgb(57, 77, 84); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 23.7999992370605px; background-color: rgb(255, 255, 255);">有两种形式</span>:</p><ul><li><p><code>COPY &lt;src&gt;... &lt;dest&gt;</code></p></li><li><p><code>COPY ["&lt;src&gt;"... "&lt;dest&gt;"]</code>&nbsp;(this form is required for paths containing whitespace)</p></li></ul><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><span style="color: rgb(57, 77, 84); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 23.7999992370605px; background-color: rgb(255, 255, 255);">COPY指令从src中copy 内容到当前容器的文件系统中。</span></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">COPY与ADD的主要不同是：</p><p style="margin-top: 0px; margin-bottom: 1em; padding: 0px; border: 0px; font-size: 15px; clear: both; color: rgb(34, 34, 34); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19.5px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp; In a nutshell the major difference is that&nbsp;<code>ADD</code>&nbsp;can do more than&nbsp;<code>COPY</code>:</p><ul><li><p><code>ADD</code>&nbsp;allows&nbsp;<code>&lt;src&gt;</code>&nbsp;to be an URL</p></li><li><p>If the&nbsp;<code>&lt;src&gt;</code>&nbsp;parameter of&nbsp;<code>ADD</code>&nbsp;is an archive in a recognised compression format, it will be unpacked</p><p><br></p></li></ul><h2>ENTRYPOINT</h2><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">ENTRYPOINT 有两种形式:</p><ul><li><p><code>ENTRYPOINT ["executable", "param1", "param2"]</code>&nbsp;(the preferred&nbsp;<em>exec</em>&nbsp;form)</p></li><li><p><code>ENTRYPOINT command param1 param2</code>&nbsp;(<em>shell</em>&nbsp;form)</p></li></ul><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><span style="color: rgb(57, 77, 84); font-family: monospace; font-size: 14px; line-height: 23.7999992370605px; background-color: rgb(255, 255, 255);">&nbsp;ENTRYPOINT<strong>它可以让你的容器功能表现得像一个可执行程序一样</strong>。</span></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><a href="http://www.programfish.com/blog/?p=151" target="_blank" rel="nofollow"><span style="color: rgb(57, 77, 84); font-family: monospace; font-size: 14px; line-height: 23.7999992370605px; background-color: rgb(255, 255, 255);"><span style="color: rgb(57, 77, 84); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 23.7999992370605px; background-color: rgb(255, 255, 255);">ENTRYPOINT VS CMD</span></span></a> &nbsp;<span style="color: rgb(57, 77, 84); font-family: monospace; line-height: 23.7999992370605px; background-color: rgb(255, 255, 255);"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 23.7999992370605px;"><a href="http://blog.stapps.io/docker-cmd-vs-entrypoint/" target="_blank" rel="nofollow">ENTRYPOINT VS CMD</a></span></span></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><span style="color: rgb(57, 77, 84); font-family: monospace; line-height: 23.7999992370605px; background-color: rgb(255, 255, 255);"><strong>docker run命令如果指定了参数会把CMD里的参数覆盖</strong></span></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><span style="font-size: 24px; font-weight: 600; font-family: 微软雅黑, Verdana, sans-serif, 宋体;">VOLUME</span></p><pre class="prettyprint well">VOLUME&nbsp;["/data"]</pre><p style="margin-top: 0px; margin-bottom: 1em; color: rgb(57, 77, 84); white-space: normal;"><span style="font-weight: 600;"><span style="font-weight: 600; font-size: 14px; line-height: 23.7999992370605px; background-color: rgb(255, 255, 255);"><span style="font-family:Helvetica Neue, Helvetica, Arial, sans-serif">VOLUME 指令为指定的名称创建挂载点，标识它持有外部的来自原生主机或其他容器挂载卷</span></span><span style="font-family: 宋体, SimSun; font-size: 12px; line-height: 18px; font-weight: 600; background-color: rgb(246, 246, 246);">。</span></span></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><span style="font-family: 微软雅黑, Verdana, sans-serif, 宋体; font-size: 24px; font-weight: 600; line-height: 18px; background-color: rgb(246, 246, 246);">USER</span><br></p><pre class="prettyprint well">USER&nbsp;daemon</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">USER 指令设定 用户名或UID 当运行镜像时。</p><h2>WORKDIR</h2><pre class="prettyprint well">WORKDIR&nbsp;/path/to/workdir</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">为接下的命令 如 RUN CMD ENTRYPOINT COPY等命令设定工作目录。</p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">在一个Dockerfile中该命令可以被运行多次。可以设定相对路径如下：</p><pre class="prettyprint well">WORKDIR&nbsp;/a
WORKDIR&nbsp;b
WORKDIR&nbsp;c
RUN&nbsp;pwd</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;<code>pwd</code>&nbsp;command &nbsp;的输出将在 &nbsp;<code>/a/b/c</code>.</p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">WORKDIR 可以利用环境变量的设定的值 如下：</p><pre class="prettyprint well">ENV&nbsp;DIRPATH&nbsp;/path
WORKDIR&nbsp;$DIRPATH/$DIRNAME</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><br></p><h2>ONBUILD</h2><pre class="prettyprint well">ONBUILD&nbsp;[INSTRUCTION]</pre><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;ONBUILD命令添加触发器指令到镜像，当镜像是被其他镜像作为base Image ,该触发器将被执行。</p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp; <strong>This is it in a nutshell:</strong><span style="color: rgb(51, 51, 51); font-family: Lato, 'Helvetica Neue', Helvetica, sans-serif; font-size: 17px; letter-spacing: 0.400000005960465px; line-height: 28.8999996185303px; background-color: rgb(255, 255, 255);">&nbsp;The&nbsp;</span><code>ONBUILD</code><span style="color: rgb(51, 51, 51); font-family: Lato, 'Helvetica Neue', Helvetica, sans-serif; font-size: 17px; letter-spacing: 0.400000005960465px; line-height: 28.8999996185303px; background-color: rgb(255, 255, 255);">&nbsp;directive gives parent Dockerfiles a way to specify instructions that must be carried out by child images but that can't be done at the parent's build stage because it depends on the build context that will only be available during when the child image is being built.</span></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: Lato, 'Helvetica Neue', Helvetica, sans-serif; font-size: 17px; letter-spacing: 0.400000005960465px; line-height: 28.8999996185303px; background-color: rgb(255, 255, 255);">参照&nbsp;<a href="http://www.eikonomega.com/dockerfile-understand-onbuild/" target="_self" rel="nofollow">http://www.eikonomega.com/dockerfile-understand-onbuild/</a><br></span></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><br></p><p style="margin-top: 0px; margin-bottom: 1em; font-size: 14px; color: rgb(57, 77, 84); line-height: 23.7999992370605px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">转发来源：<a href="http://my.oschina.net/robinyao/blog/423036" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/423036</a></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_418953" href="http://my.oschina.net/robinyao/blog/418953">单元测试覆盖率-maven插件-jacoco</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-05-23 21:21:39</div>
	  <div class='catalog'>分类：java</div>
	  	  	  <div class='tags'>标签：java,junit,code,coverage,maven,jacoco</div>	  	  	  </div>
      <div class='content'><p>&nbsp;&nbsp;&nbsp;&nbsp;J<a href="http://www.eclemma.org/jacoco/" target="_blank" rel="nofollow">aCoCo</a>&nbsp;提供基于Java VM环境的代码覆盖率分析标准技术。主要提供了一个轻量 、弹性化、文档化的包，可以与各类构建开发工具整合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;</p><h2>Features</h2><ul><li><p>提供了指令，分支（if ,switch等），<span style="font-family: sans-serif; font-size: 13.3333330154419px; line-height: 24px;">lines, methods, types 和 cyclomatic complexity.</span><br></p></li><li><p>基于java 字节码，因此没有源代码也可正常工作</p></li><li><p>集成了java agent.</p></li><li><p>兼容各个版本的JDK</p></li><li><p>支持其他的JVM语言</p></li><li><p>报表形式有html xml csv</p><p><br></p></li></ul><h2>Prerequisites</h2><p style="font-family: sans-serif; font-size: 13.3333330154419px; line-height: normal; white-space: normal;">&nbsp; JaCoCo Maven plug-in 要求</p><ul><li><p>Maven 2.1.0 或着以上版本</p></li><li><p>Java 1.5 或者以上版本</p></li></ul><h2>Usage</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;直接在项目的pom文档中添加下面插件即可，如果是多module项目，可以在根pom中添加，默认产生的报表在每个项目的target目录中。</p><pre class="brush:java;toolbar: true; auto-links: false;">&lt;plugin&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.jacoco&lt;/groupId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;0.7.0.201403182114&lt;/version&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;executions&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;execution&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;goals&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;goal&gt;prepare-agent&lt;/goal&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/goals&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/execution&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;execution&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;id&gt;report&lt;/id&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;phase&gt;prepare-package&lt;/phase&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;goals&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;goal&gt;report&lt;/goal&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/goals&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/execution&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/executions&gt;
&lt;/plugin&gt;</pre><p style="font-family: sans-serif; font-size: 13.3333330154419px; line-height: normal; white-space: normal;">获取jacoco插件全部的goal和参数 可以用下面的命令</p><pre>mvn&nbsp;help:describe&nbsp;-Dplugin=org.jacoco:jacoco-maven-plugin&nbsp;-Ddetail</pre><h2><br></h2><h2>Goals</h2><p style="font-family: sans-serif; font-size: 13.3333330154419px; line-height: normal; white-space: normal;">The JaCoCo Maven plug-in defines the following goals:</p><ul><li><p><a href="http://www.eclemma.org/jacoco/trunk/doc/help-mojo.html" target="_blank" rel="nofollow">help</a></p></li><li><p><a href="http://www.eclemma.org/jacoco/trunk/doc/prepare-agent-mojo.html" target="_blank" rel="nofollow">prepare-agent</a></p></li><li><p><a href="http://www.eclemma.org/jacoco/trunk/doc/prepare-agent-integration-mojo.html" target="_blank" rel="nofollow">prepare-agent-integration</a></p></li><li><p><a href="http://www.eclemma.org/jacoco/trunk/doc/merge-mojo.html" target="_blank" rel="nofollow">merge</a></p></li><li><p><a href="http://www.eclemma.org/jacoco/trunk/doc/report-mojo.html" target="_blank" rel="nofollow">report</a></p></li><li><p><a href="http://www.eclemma.org/jacoco/trunk/doc/report-integration-mojo.html" rel="nofollow">report-integration</a></p></li><li><p><a href="http://www.eclemma.org/jacoco/trunk/doc/check-mojo.html" rel="nofollow">check</a></p></li><li><p><a href="http://www.eclemma.org/jacoco/trunk/doc/dump-mojo.html" rel="nofollow">dump</a></p></li><li><p><a href="http://www.eclemma.org/jacoco/trunk/doc/instrument-mojo.html" rel="nofollow">instrument</a></p></li><li><p><a href="http://www.eclemma.org/jacoco/trunk/doc/restore-instrumented-classes-mojo.html" rel="nofollow">restore-instrumented-classes</a></p></li></ul><p><br></p><p>转发标注：<a href="http://my.oschina.net/robinyao/blog/418953" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/418953</a></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_415934" href="http://my.oschina.net/robinyao/blog/415934">Storm Tutorial</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-05-17 16:27:42</div>
	  <div class='catalog'>分类：storm</div>
	  	  	  <div class='tags'>标签：storm,java,流计算,turial</div>	  	  	  </div>
      <div class='content'><h1>Tutorial</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://storm.apache.org/documentation/Tutorial.html" target="_blank" rel="nofollow">原文地址</a><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在本教程中，你将学会如何创建Storm Topologies 并且部署它们到storm集群中。Java是主要用到的语言，少数例子用python来解释Storm的多语言功能。<br></p><h2>Preliminaries</h2><p>&nbsp; &nbsp; 该教程用到 &nbsp;<a href="https://github.com/apache/storm/tree/master/examples/storm-starter" target="_blank" rel="nofollow">storm-starter</a>中的例子。建议clone该项目，跟着里面的例子学习。搭建<a href="https://storm.apache.org/documentation/Setting-up-development-environment.html" target="_blank" rel="nofollow">storm开发环境</a> ，并且在本机创建一个<a href="https://storm.apache.org/documentation/Creating-a-new-Storm-project.html" target="_blank" rel="nofollow">Storm &nbsp;Project&nbsp;</a><br></p><h2>Components of a Storm cluster</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;storm集群和hadoop集群很类似。在Hadoop上，我们跑 MapReduce Jobs, 而在storm集群中我们跑topologies。Jobs 和 topologies本身是非常不一样的，一个重要的不同是：MapReduce &nbsp;job最终会结束，而topology将一直处理消息，直到你杀死它。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;storm集群中有两类节点:master节点，worker节点。master节点运行一个叫作"Nimbus"的守护进程，类似于Hadoop中的 JobTracker。Nimbus负责在集群中分发代码，分配任务到各个worker，并且监控failures。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;每个worker节点运行一个叫作Supervisor的守护进程。Supervisor监听Nimbus分配给它的work,根据Nimbus的分配开始或停止Worker 进程。每个worker进程执行一个topology的子集；一个运行的topology包含运行在很多节点上的worker进程。<br></p><p><img src="http://static.oschina.net/uploads/img/201505/17162943_wYez.png" alt="Storm cluster"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;Nimbus和Supervisors之间的协作通过Zookeeper集群来完成。另外 Nimbus进程与Supervisor进程 都是快速失败的，并且是无状态的；所有的状态保存在zookeeper或者本地磁盘中。这意味着你可以通过kill -9 结束Nimbus和 Supervisors，然后可以像没发生任何事情一样重启。这种设计保证storm的稳定性。</p><h2>Topologies</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在storm上集群实现实时计算，你可以创建topologies。一个topology是一个计算图。在topology中的每个节点都包含一个处理逻辑,节点之间的关联，表明数据应该在节点之间传输。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;运行一个topology是简单的。首先你把所有的代码和依赖打包成一个单独的jar。然后运行如下的命令：<br></p><pre class="brush:java;toolbar: true; auto-links: false;">storm&nbsp;jar&nbsp;all-my-code.jar&nbsp;backtype.storm.MyTopology&nbsp;arg1&nbsp;arg2</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;加上参数 arg1 arg2 ,运行backtype.storm.MyToplogy类。该类主要的功能是定义了topology，并提交它到Nimbus。storm jar负责连接Nimbus,并将jar上传到Nimbus上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于topology的定义是Thrift结构，并且Nimbus是一个Thrift服务,所以你可以用任何语言创建提交topologies。上面的例子主要是基于JVM语言的方式。开始结束topologies具体信息见<a href="https://storm.apache.org/documentation/Running-topologies-on-a-production-cluster.html" target="_blank" rel="nofollow">Running topologies on a production cluster</a></p><h2>Streams</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在storm中核心的抽象概念是stream。一个stream代表一个无界的tuples(元组)。storm用分布式，可靠的方式提供原语来把stream转化为新的stream。例如，你可以把tweets流转化为话题趋势流。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;storm提供的最基本的原语是Spout和bolt。Spout和bolt包含你要实现的接口，在接口里面，你要实现自己的程序逻辑。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;一个Spout是streams的来源。例如，spout可以从消息队列中读取tuples，并把它们作为stream提交。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;一个Bolt消费任何数量的输入流，并处理这些流，处理完有可能把结果作为新的流提交。复杂的流转化需要很多步骤，需要在多个bolts之间传输。 Bolts 可以运行任何函数，比如filter tuples，或者做stream聚合,持久化结果数据。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;Spouts与Bolts之间的网络结构被打包成"topology",topology是一个高度抽象的概念，是一个流转换图，图中的连线代表流的流转方向。<br></p><p><img src="http://static.oschina.net/uploads/img/201505/17162944_rItd.png" alt="A Storm topology"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在storm toplogy中，每个节点都是并行的。在你的topology中，你可以为每个节点指定有多少并行。Storm将根据集群生成一定数量的线程来执行操作。<br></p><h2>Data model</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Storm用元组作为数据模型。一个元组代表一组值。在元组中一个字段可以是任意类型的数据。如果用Object类型的，你需要<a href="https://storm.apache.org/documentation/Serialization.html" target="_blank" rel="nofollow">实现序列化接口</a>。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在topology中你必须声明输出的字段。例如，下面的bolt声明了一个2个元素的tuple:'double','triple'<br></p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;DoubleAndTripleBolt&nbsp;extends&nbsp;BaseRichBolt&nbsp;{&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;OutputCollectorBase&nbsp;_collector;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;prepare(Map&nbsp;conf,&nbsp;TopologyContext&nbsp;context,&nbsp;OutputCollectorBase&nbsp;collector)&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_collector&nbsp;=&nbsp;collector;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;execute(Tuple&nbsp;input)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;val&nbsp;=&nbsp;input.getInteger(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_collector.emit(input,&nbsp;new&nbsp;Values(val*2,&nbsp;val*3));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_collector.ack(input);
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;declareOutputFields(OutputFieldsDeclarer&nbsp;declarer)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;declarer.declare(new&nbsp;Fields("double",&nbsp;"triple"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;declareOutputFields 声明输出字段 ‘double’,'triple'。剩下的部分将在下面的部分讲解。</p><h2>A simple topology</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;下面我们看一个简单的topology，并探索里面简单的概念。我们看storm-starter中 ExclamationTopology概念。<br></p><pre class="brush:java;toolbar: true; auto-links: false;">TopologyBuilder&nbsp;builder&nbsp;=&nbsp;new&nbsp;TopologyBuilder();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;builder.setSpout("words",&nbsp;new&nbsp;TestWordSpout(),&nbsp;10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;builder.setBolt("exclaim1",&nbsp;new&nbsp;ExclamationBolt(),&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.shuffleGrouping("words");&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;builder.setBolt("exclaim2",&nbsp;new&nbsp;ExclamationBolt(),&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.shuffleGrouping("exclaim1");</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;该topology中包含一个spout 两个bolt 。spout提交words，每个bolt添加'!!!'到它的输入中。spout提交到第一个bolt，然后这个bolt把结果提交到第二个bolts。如果spout提交'bob',最后结果将会'bob!!!!!!'</p><p>&nbsp;&nbsp;&nbsp;&nbsp;用setSpout与setBolt方法定义节点。这些方法接受用户指定的ID，和一个处理逻辑的对象，以及你想要该节点的并行度。<br></p><p>处理逻辑对象的Spout与bolt必须实现相应的借口，spout要实现IRichSout,bolt要实现IRichBolt。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;最后一个并行数据的参数可以省落。它代表多少个线程来处理改逻辑代码。如果省落，表明只有一个线程来处理。<br></p><p>setBolt 返回一个 InputDeclarer 对象，用来定义对bolt的输入。这里的exclaim1用shuffle grouping 代表它想读所有的 words 的输出。exclaim2用shuffle grouping代表它要读exclaim1的所有输出。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你想要exlaim2读取所有的words 与 exclaim1 组件的输出，你可以像下边的方式下<br></p><pre class="brush:java;toolbar: true; auto-links: false;">&nbsp;&nbsp;&nbsp;&nbsp;builder.setBolt("exclaim2",&nbsp;new&nbsp;ExclamationBolt(),&nbsp;5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.shuffleGrouping("words")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.shuffleGrouping("exclaim1");</pre><p>&nbsp;如你所见，对于bolt的输入可以指定多个sources。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们下面看下topology中spout bolt的具体实现。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;TestWordSpout 每100ms 提交随机的单词,TestWordSpout中的nextTuple()的实现如下<br></p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;void&nbsp;nextTuple()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Utils.sleep(100);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;String[]&nbsp;words&nbsp;=&nbsp;new&nbsp;String[]&nbsp;{"nathan",&nbsp;"mike",&nbsp;"jackson",&nbsp;"golda",&nbsp;"bertels"};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Random&nbsp;rand&nbsp;=&nbsp;new&nbsp;Random();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;String&nbsp;word&nbsp;=&nbsp;words[rand.nextInt(words.length)];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;_collector.emit(new&nbsp;Values(word));&nbsp;
}</pre><p>ExclamationBolt只往输入的内容中添加'!!!'，下面是具体的实现<br></p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;static&nbsp;class&nbsp;ExclamationBolt&nbsp;implements&nbsp;IRichBolt&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;OutputCollector&nbsp;_collector;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;prepare(Map&nbsp;conf,&nbsp;TopologyContext&nbsp;context,&nbsp;OutputCollector&nbsp;collector)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_collector&nbsp;=&nbsp;collector;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;execute(Tuple&nbsp;tuple)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_collector.emit(tuple,&nbsp;new&nbsp;Values(tuple.getString(0)&nbsp;+&nbsp;"!!!"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_collector.ack(tuple);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;cleanup()&nbsp;{&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;declareOutputFields(OutputFieldsDeclarer&nbsp;declarer)&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;declarer.declare(new&nbsp;Fields("word"));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Map&nbsp;getComponentConfiguration()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;}</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;prepare方法提供了outPutCollector供提交tuples用。元组在任何时间从bolt提交：prepare,execute ,cleanup ,甚至在异步线程中都可以提交tuple。该prepare方法仅仅把OutputCollector实例保存到本地变量引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;execute方法仅仅接收tuple,并在第一个filed后添加 '!!!'，然后提交。如果你实现了多源输入，你可以通过Tuple.getSourceComponet获取输入来自哪个源。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;cleanup方法主要是用来当bolt关闭时，用来清理关闭打开的资源。不保证该方法在关闭的时候一定被调用。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;declareOutputFields用来声明ExclaimationBolt的提交的tuple元素字段。<br></p><p>cleanup与getComponentConfiguration不必实现。所以你可以定义bolt用一个默认的基类：BaseRichBolt</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;static&nbsp;class&nbsp;ExclamationBolt&nbsp;extends&nbsp;BaseRichBolt&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;OutputCollector&nbsp;_collector;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;prepare(Map&nbsp;conf,&nbsp;TopologyContext&nbsp;context,&nbsp;OutputCollector&nbsp;collector)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_collector&nbsp;=&nbsp;collector;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;execute(Tuple&nbsp;tuple)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_collector.emit(tuple,&nbsp;new&nbsp;Values(tuple.getString(0)&nbsp;+&nbsp;"!!!"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_collector.ack(tuple);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;declareOutputFields(OutputFieldsDeclarer&nbsp;declarer)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;declarer.declare(new&nbsp;Fields("word"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;}</pre><h2>Running ExclamationTopology in local mode</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Storm有两种运行模式：<a href="https://storm.apache.org/documentation/Local-mode.html" target="_blank" rel="nofollow">本地模式</a> ，<a href="https://storm.apache.org/documentation/Running-topologies-on-a-production-cluster.html" target="_blank" rel="nofollow">分布式模式</a>。本地模式，Storm用多线程模拟worker处理过程。本地模式在测试开发过程是很有用的。当你运行storm-starter中的例子，它们将用本地模式启动，你能看到每个组件的提交消息。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;分布式模式中， storm操作所有的机器作为一个集群。当你提交一个topology到master上，你必须也到提交所有的依赖代码到topology中。master将分发你的代码到集群，并且分配worker来跑topology。如果worker挂了， master将会重新分配任务到别的地方。下面是一个本地模式topology<br></p><pre class="brush:java;toolbar: true; auto-links: false;">&nbsp;&nbsp;&nbsp;&nbsp;Config&nbsp;conf&nbsp;=&nbsp;new&nbsp;Config();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;conf.setDebug(true);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;conf.setNumWorkers(2);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;LocalCluster&nbsp;cluster&nbsp;=&nbsp;new&nbsp;LocalCluster();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;cluster.submitTopology("test",&nbsp;conf,&nbsp;builder.createTopology());&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Utils.sleep(10000);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;cluster.killTopology("test");&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;cluster.shutdown();</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;上边的代码通过LocalCluster定义了集群。通过提交topologies到虚拟集群与提交到分布式集群是一致的。LocalCluster通过调用submitTopology，加上topology的名字参数，配置参数，及topology对象本身。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;name参数是用来区分topology的，你可以通过name来kill topology。一个topology将一直运行直到你kill 它。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;config是用来调优topology运行的各个方面。下面两个配置是经常的：<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）TOPOLOGY_WORKERS（setNumWorkers） ：指定了节点的worker数量。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）TOPOLOGY_DEBUG(setDebug)：当设为true时，storm 将打印每条被组件提交的消息。这对调试很有帮助。<br></p><h2>Stream groupings</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;stream grouping告诉topology两个组件之间如何发送tuples。spouts 和bolts 都是以并行的方式来执行的。下边的图展示topology执行task的状态:<br></p><p><img src="http://static.oschina.net/uploads/img/201505/17162945_SCcd.png" alt="Tasks in a topology"></p><p>stream grouping 告诉storm 在任务集中如何去发送tuples。有以下几个种类型的grouping:<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;1) shuffle grouping: tuples在bolt的任务集中是是被随机分配的，每个bolts都会得到相同数量的tuples。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2）fields grouping:stream将被fileds分成不同的部分。如何group by 'user-id'，那么相同user-id的 tuples将会被流向同一个task,不同的user-id或许流向不同的task.<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;3)all grouping:所有的stream将会被流向所有的tasks。应该小心的用这种grouping。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;4)global grouping:整个stream流向bolt的一个单一task。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;5）none grouping:不指定grouping ,效果类似shuffle grouping。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;6）direct grouping: stream的生产者决定stream的流向。<br></p><h2>Guaranteeing message processing</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://storm.apache.org/documentation/Guaranteeing-message-processing.html" target="_blank" rel="nofollow">Guaranteeing message processing</a></p><h2>Transactional topologies</h2><p><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">&nbsp;</span><a href="https://storm.apache.org/documentation/Transactional-topologies.html" target="_blank" rel="nofollow">Transactional-topology</a>&nbsp;</p><h2>Distributed RPC</h2><p><a href="https://storm.apache.org/documentation/Distributed-RPC.html" target="_blank" rel="nofollow">Distributed-RPC</a></p><p><br></p><p>转载标注：<a href="http://my.oschina.net/robinyao/blog/415934" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/415934</a></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_415757" href="http://my.oschina.net/robinyao/blog/415757">Storm 0.9 集群搭建</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-05-16 20:54:15</div>
	  <div class='catalog'>分类：storm</div>
	  	  	  <div class='tags'>标签：storm,java,流计算</div>	  	  	  </div>
      <div class='content'><p>搭建Storm 0.9 集群的主要步骤有以下几步：<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;1 搭建Zookeeper集群<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2 在 Nimbus和 worker上安装相应的依赖<br></p><p>&nbsp; &nbsp; 3 下载Storm 到 Nimbus 和worker机器上</p><p>&nbsp;&nbsp;&nbsp;&nbsp;4 在storm.yaml填写必须的配置<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;5 用storm脚本启动storm集群<br></p><p>1搭建zookeeper集群</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Storm主要用Zookeeper来协调集群的。Zookeeper不是用来作为消息传递的，所以Storm对Zookeeper的负载是低的。单节点集群足以满足storm需求。如果需要zookeeper 的failover可以搭建多节点的zookeeper集群。具体搭建zookeeper &nbsp;步骤，这里不详细写了。<br></p><p>2在机器上安装相应的JDK和python<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;JDK版本最低为 1.6<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;Python版本最低为2.6.6<br></p><p>3下载storm到相应的机器上<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;最新版本为0.94 &nbsp;<a href="https://github.com/apache/storm/releases" target="_self" rel="nofollow">下载</a> &nbsp; &nbsp;解压提取到相应的Nimbus和worker机器上。</p><p>4在storm.yaml填写必须的配置项</p><p>&nbsp; &nbsp;1)<span style="box-sizing: border-box; font-weight: 700; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">storm.zookeeper.servers</span><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">:</span></p><pre class="brush:xml;toolbar: true; auto-links: false;">storm.zookeeper.servers:&nbsp;&nbsp;
&nbsp;-&nbsp;"111.222.333.444"&nbsp;&nbsp;
&nbsp;-&nbsp;"555.666.777.888"</pre><p><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"></span>如果zookeeper端口不是默认端口，必须填写端口配置</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="box-sizing: border-box; font-weight: 700; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">storm.zookeeper.port</span></p><p><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; font-weight: 700; line-height: 20px; background-color: rgb(255, 255, 255);">&nbsp; &nbsp; 2)&nbsp;</span><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; font-weight: 700; line-height: 20px; box-sizing: border-box; background-color: rgb(255, 255, 255);">storm.local.dir</span><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; font-weight: 700; line-height: 20px; background-color: rgb(255, 255, 255);">:<span style="color: rgb(51, 51, 51); font-family: 微软雅黑, 'Microsoft YaHei'; font-size: 12px; font-weight: 700; line-height: 20px; background-color: rgb(255, 255, 255);">主要是nimbus和<span style="color: rgb(51, 51, 51); font-family: 微软雅黑, 'Microsoft YaHei'; font-weight: 700; line-height: 20px; background-color: rgb(255, 255, 255);">Supervisor用来保存状态的地方，在每台机子上都有建立相应的目录，并且赋予相应的权限。</span></span></span></p><p><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; font-weight: 700; line-height: 20px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;eg:</span></p><pre class="brush:xml;toolbar: true; auto-links: false;">storm.local.dir:&nbsp;"/mnt/storm"</pre><p><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; font-weight: 700; line-height: 20px; background-color: rgb(255, 255, 255);"></span><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">&nbsp; &nbsp;3)&nbsp;</span><span style="box-sizing: border-box; font-weight: 700; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">nimbus.host</span><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">: worker节点需要知道哪个节点是master,以便用来下载topology的 jar和配置</span></p><pre class="brush:xml;toolbar: true; auto-links: false;">nimbus.host:&nbsp;"111.222.333.44"</pre><p><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"></span> &nbsp;<span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">4)&nbsp;</span><span style="box-sizing: border-box; font-weight: 700; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">supervisor.slots.ports</span><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">:对于每个worker节点需要配置多少个worker运行在该节点上。每个worker用单独的port接收消息，如果你配置五个端口，表明五个 worker运行在该机器上，如果3个表明3个worker运行在该机器上。默认是四个worker在一台机子上。</span></p><pre class="brush:xml;toolbar: true; auto-links: false;">supervisor.slots.ports:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;6700&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;6701&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;6702&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;6703</pre><p><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"></span><br></p><p>5用storm脚本启动相应的程序</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1）<span style="box-sizing: border-box; font-weight: 700; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">Nimbus</span><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">: 在master节点上 &nbsp;&nbsp;<span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">bin/storm nimbus &nbsp; 用来启动nimbus</span></span></p><p><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp; 2)&nbsp;<span style="box-sizing: border-box; font-weight: 700; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">Supervisor</span><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">:在每台worker节点上 &nbsp;bin/storm supervisor 用来启动supervisor &nbsp;,supervisor用来启动和关闭本机器上的worker</span></span></span></p><p><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp; 3) UI: 在master节点上 bin/storm ui ，主要用来在浏览器中查看storm集群的状态，<span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">http://{nimbus host}:8080</span></span></span></span></p><p><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><br></span></span></span></span></p><p><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><br></span></span></span></span></p><p><span style="font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">单机伪集群的全部配置如下</span></p><pre class="brush:java;toolbar: true; auto-links: false;">&nbsp;storm.zookeeper.servers:
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;"127.0.0.1"
&nbsp;storm.zookeeper.port:&nbsp;2181&nbsp;
&nbsp;storm.local.dir:&nbsp;"/home/xxx/storm/workdir"
&nbsp;nimbus.host:&nbsp;"127.0.0.1"

&nbsp;supervisor.slots.ports:
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;6700
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;6701
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;6702
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;6703</pre><p><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);"></span></span></span></span><br></p><p><span style="font-size: 14px; line-height: 20px; background-color: rgb(255, 255, 255);">主要参照 &nbsp;<a href="https://storm.apache.org/documentation/Setting-up-a-Storm-cluster.html" target="_blank" rel="nofollow">https://storm.apache.org/documentation/Setting-up-a-Storm-cluster.html</a>&nbsp; 翻译</span></p><p><br></p><p>转载标注：<a href="http://my.oschina.net/robinyao/blog/415757" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/415757</a></p><p><br></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_410048" href="http://my.oschina.net/robinyao/blog/410048">统计Redis中各种数据大小</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-05-03 16:28:30</div>
	  <div class='catalog'>分类：shell</div>
	  	  	  <div class='tags'>标签：shell,redis</div>	  	  	  </div>
      <div class='content'><p>&nbsp; &nbsp; 本文参照 火丁笔记 的 &nbsp;<a href="http://huoding.com/2015/03/25/425" target="_blank" rel="nofollow">如何统计Redis中各种数据的大小</a> &nbsp;，该文章用php 和redis自带的 scan 和 debug信息来统计redis内存中各种数据结构（raw ,ziplist ,embstr等&nbsp;）相对大小（序列化后的value 长度）。</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;下面是本人通过shell ，利用redis-cli 和 debug 写的一个小脚本，来统计redis中各数据结构的相对大小<br></p> 
<pre class="brush:java;toolbar: true; auto-links: false;">#!/bin/bash
redis-cli&nbsp;--scan&nbsp;|&nbsp;&nbsp;while&nbsp;read&nbsp;line
do
&nbsp;&nbsp;redis-cli&nbsp;DEBUG&nbsp;OBJECT&nbsp;"$line"&nbsp;|&nbsp;awk&nbsp;'{&nbsp;print&nbsp;$4":"$5&nbsp;}'
done&nbsp;|&nbsp;awk&nbsp;-F&nbsp;':'&nbsp;'{counter[$2]+=$4;&nbsp;}&nbsp;END{&nbsp;for&nbsp;(&nbsp;i&nbsp;in&nbsp;counter&nbsp;)&nbsp;print&nbsp;(&nbsp;i,":"&nbsp;,counter[i])}&nbsp;'</pre> 
<p><br></p></div>
	  	  <div class='commentList'>
		<h3>评论列表</h3>
	    	    <div class='comment'>
		  <div class='author'>Kent_Chen</div>
		  <div class='date'>2015-05-05 14:03:14</div>
		  <div class='content'>计算结果中的单位是byte吗</div>
		</div>
			    <div class='comment'>
		  <div class='author'>robin-yao</div>
		  <div class='date'>2015-05-05 14:04:11</div>
		  <div class='content'><div class='ref'><h4>引用来自“Kent_Chen”的评论</h4>计算结果中的单位是byte吗</div>不是 ，好像是序列化后的字符长度，你确认下</div>
		</div>
			  </div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_409153" href="http://my.oschina.net/robinyao/blog/409153">编写maven插件介绍</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-05-02 22:07:37</div>
	  <div class='catalog'>分类：java</div>
	  	  	  <div class='tags'>标签：maven,plugin,java</div>	  	  	  </div>
      <div class='content'><p>&nbsp;&nbsp;&nbsp;&nbsp;本文主要介绍编写自定义maven插件的基本步骤，以及如何打包发布，调用。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;项目搭建：<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;和搭建普通的java项目相同，可以通过 IDE idea &nbsp;的create from archetype中选择<span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">&nbsp;maven-archetype-mojo即可。也可以自己创建普通的maven项目，自己往里面放要引用的jar包和插件。</span></p><p><span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;下面是项目中用到的jar和插件</span></p><pre class="brush:xml;toolbar: true; auto-links: false;">&lt;dependencies&gt;
&nbsp;&nbsp;&lt;dependency&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;2.0&lt;/version&gt;
&nbsp;&nbsp;&lt;/dependency&gt;
&nbsp;&nbsp;&lt;dependency&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;maven-model&lt;/artifactId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;2.2.1&lt;/version&gt;
&nbsp;&nbsp;&lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;build&gt;
&nbsp;&nbsp;&lt;plugins&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;plugin&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;maven-plugin-plugin&lt;/artifactId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;2.5.1&lt;/version&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;configuration&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;goalPrefix&gt;hello&lt;/goalPrefix&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/configuration&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/plugin&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;plugin&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;2.5.1&lt;/version&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;configuration&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;source&gt;1.8&lt;/source&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;target&gt;1.8&lt;/target&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/configuration&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/plugin&gt;
&nbsp;&nbsp;&lt;/plugins&gt;
&lt;/build&gt;</pre><p><span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"></span>&nbsp;&nbsp;&nbsp;&nbsp;其中&lt;goalPrefix&gt;hello&lt;/goalPrefix&gt;是为了当我们把插件发布后，<span style="background-color: rgb(255, 0, 0); ">调用就可以直接用hello来调用，类是我们经常用到的eclipse:eclipse。前面代表插件，后面代表要执行的maven goal。</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;要编写maven插件，必须要编写一个MOJO(即Maven old java object)，一个普通的maven java类对象。所有的MOJO必须继承AbstractMojo的类。下面是一个HelloMojo类：</p><pre class="brush:java;toolbar: true; auto-links: false;">package&nbsp;com.yao;
import&nbsp;org.apache.maven.plugin.AbstractMojo;
import&nbsp;org.apache.maven.plugin.MojoExecutionException;
import&nbsp;org.apache.maven.plugin.MojoFailureException;
/**
&nbsp;*&nbsp;@goal&nbsp;hello
&nbsp;*
&nbsp;*/
public&nbsp;class&nbsp;HelloMojo&nbsp;extends&nbsp;AbstractMojo&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;execute()&nbsp;throws&nbsp;MojoExecutionException,&nbsp;MojoFailureException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getLog().info("hello&nbsp;maven&nbsp;plugin");
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>仅仅在调用的时候打印一句话。<span style="background-color: rgb(255, 0, 0); ">一定要注意 <a href="http://my.oschina.net/u/930890" target="_blank" rel="nofollow">@goal</a> 就相当有给HelloMojo起了一个名称，这个goal一定不要忘记</span></p><p>然后就是编译打包：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;直接在当前项目的根目录下运行：mvn clean install &nbsp; 就把当前的maven插件打到本地的reposity里了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;调用： &nbsp;mvn com.yao:maven-plugin-hello:1.0-SNAPSHOT:hello</p><p>&nbsp;&nbsp;&nbsp;&nbsp;首先要写上插件的groupId &nbsp;然后是插件的名称 版本 ，最后要调用插件的goal。这样调用我们要写很多的东西，可以通过在本地maven setting.xml中添加如下内容</p><pre class="brush:xml;toolbar: true; auto-links: false;">&nbsp;&nbsp;&lt;pluginGroups&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;pluginGroup&gt;com.yao&lt;/pluginGroup&gt;
&nbsp;&lt;/pluginGroups&gt;</pre><p>&nbsp; 这样之后我们调用就直接可以用插件代号加goal来调用了：mvn hello:hello &nbsp;</p><p>这样maven插件helloworld就完成了。</p><p>下面介绍一个稍微复杂的goal,通过在编译代码的时候往源代码的头里加上版权信息。下面是具体代码</p><pre class="brush:java;toolbar: true; auto-links: false;">package&nbsp;com.yao;
import&nbsp;org.apache.maven.plugin.AbstractMojo;
import&nbsp;org.apache.maven.plugin.MojoExecutionException;
import&nbsp;org.apache.maven.plugin.MojoFailureException;

import&nbsp;java.io.File;
import&nbsp;java.io.IOException;
import&nbsp;java.io.RandomAccessFile;
import&nbsp;java.nio.channels.FileChannel;
import&nbsp;java.util.ArrayList;
import&nbsp;java.util.List;

/**
&nbsp;*&nbsp;Created&nbsp;by&nbsp;robin&nbsp;on&nbsp;5/2/15.
&nbsp;*&nbsp;@goal&nbsp;copyright
&nbsp;*&nbsp;@execute&nbsp;phase=package
&nbsp;*/
public&nbsp;class&nbsp;CopyRight&nbsp;extends&nbsp;AbstractMojo&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;String&nbsp;&nbsp;JAVA_SUFFIX=".java";
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;String&nbsp;&nbsp;COPY_RIGHT="\n"+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/**&nbsp;CopyRight&nbsp;\n"&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"*&nbsp;xxxxxxxxxxxxxxxxx&nbsp;Robin\n"&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"*&nbsp;xxxxxxxxxxxxxxxxx&nbsp;Robin\n"&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"*&nbsp;END&nbsp;\n"+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"*/\n";
&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@parameter&nbsp;expression="${project.build.sourceDirectory}"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@required
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@readonly
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;File&nbsp;sourcedir;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;execute()&nbsp;throws&nbsp;MojoExecutionException,&nbsp;MojoFailureException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addCopyRight(sourcedir);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;addCopyRight(File&nbsp;dir){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!dir.isDirectory()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getLog().error(new&nbsp;IllegalArgumentException("源代码目录不对!"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;File&gt;&nbsp;javaFiles=new&nbsp;ArrayList&lt;File&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findJavaFiles(dir,javaFiles);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(javaFiles.size()&gt;0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(File&nbsp;file:javaFiles){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addCopyHead(file);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;findJavaFiles(File&nbsp;file,List&lt;File&gt;&nbsp;javaFiles){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getLog().info("scan&nbsp;file:"+file.getAbsolutePath());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(file.isDirectory()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(File&nbsp;child:file.listFiles()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findJavaFiles(child,javaFiles);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(file.getName().endsWith(JAVA_SUFFIX)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javaFiles.add(file);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;addCopyHead(File&nbsp;file){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(file.isDirectory()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getLog().error(new&nbsp;IllegalArgumentException("要添加版权头的必须是文件！"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try(RandomAccessFile&nbsp;randomAccessFile=new&nbsp;RandomAccessFile(file,"rw");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RandomAccessFile&nbsp;tmpFile=new&nbsp;RandomAccessFile(File.createTempFile("copy_right","tmp"),"rw")){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpFile.writeBytes(new&nbsp;String(COPY_RIGHT.getBytes("UTF-8")));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randomAccessFile.seek(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;line=null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while((line=randomAccessFile.readLine())!=null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpFile.writeBytes(new&nbsp;String(line.getBytes("UTF-8"))+"\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randomAccessFile.setLength(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileChannel&nbsp;in=tmpFile.getChannel();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileChannel&nbsp;out=randomAccessFile.getChannel();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in.transferTo(0,tmpFile.length(),out);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch&nbsp;(Exception&nbsp;e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getLog().error(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]args)&nbsp;throws&nbsp;IOException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;try(RandomAccessFile&nbsp;randomAccessFile=new&nbsp;RandomAccessFile("/home/robin/tmp/blogtmp.txt","rw")){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randomAccessFile.seek(randomAccessFile.length());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randomAccessFile.writeChars(COPY_RIGHT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch&nbsp;(Exception&nbsp;e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}*/
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>其中要注意</p><pre class="brush:java;toolbar: true; auto-links: false;">&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@parameter&nbsp;expression="${project.build.sourceDirectory}"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@required
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@readonly
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;File&nbsp;sourcedir;</pre><p>在maven运行插件的时候直接根据注释会把项目中的sourcedir注入进来，不用我们额外操作。其他的代码不解释了，就是简单的把文件添加上COPY_RIGHT 然后直接copy。其中getLog()可以把相关的信息打印到我们控制台上。<br></p><p>在项目中调用该插件：</p><pre class="brush:xml;toolbar: true; auto-links: false;">&lt;build&gt;
&lt;plugins&gt;
&nbsp;&nbsp;&nbsp;&lt;plugin&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;com.yao&lt;/groupId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;maven-plugin-hello&lt;/artifactId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;executions&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;execution&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;id&gt;start-copyright&lt;/id&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;phase&gt;compile&lt;/phase&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;goals&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;goal&gt;copyright&lt;/goal&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/goals&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/execution&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/executions&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/plugin&gt;
&lt;/plugins&gt;
&lt;/build&gt;</pre><p>这样在编译的时候会自动把版权信息加到java 源文件上了<br></p><p>demo上传到github:<a href="https://github.com/WangErXiao/maven-plugin-hello" target="_blank" rel="nofollow">https://github.com/WangErXiao/maven-plugin-hello</a></p><p>END---------------------------------------------------------------------------</p><p>转发标注来源：<a href="http://my.oschina.net/robinyao/blog/409153" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/409153</a> &nbsp; &nbsp;<br></p><p><br></p><p><br></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_408285" href="http://my.oschina.net/robinyao/blog/408285">BenchMark工具-JMH介绍</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-29 20:48:51</div>
	  <div class='catalog'>分类：java</div>
	  	  	  <div class='tags'>标签：java,benchmark,JMH,性能测试</div>	  	  	  </div>
      <div class='content'><p>&nbsp;&nbsp;&nbsp;&nbsp;JMH是有OpenJDK开发的基准测试（Benchmark）工具。JMH可以为写基准测试和运行测试提供很好的支持。JMH在C<span style="font-family: Arial, Helvetica, sans-serif; font-size: 12px; line-height: 16px; background-color: rgb(255, 255, 255);">oncurrent Benchmarks也提供很好的支持，可以说是多功能测试工具。JMH在2013被公布出来，现在最新版本到1.9。</span></p><p><span style="font-family: Arial, Helvetica, sans-serif; font-size: 12px; line-height: 16px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;JMH基本用法:</span></p><p><span style="font-family: Arial, Helvetica, sans-serif; font-size: 12px; line-height: 16px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JMH环境构建</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: Arial, Helvetica, sans-serif; font-size: 12px; line-height: 16px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;1 使用maven工程，直接在项目中引入相应的jar包</span></p><p><span style="font-family: Arial, Helvetica, sans-serif; font-size: 12px; line-height: 16px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;</span></p><pre class="brush:java;toolbar: true; auto-links: false;">&lt;dependency&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;jmh-core&lt;/artifactId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;${jmh.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;${jmh.version}&lt;/version&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre><p></p><p><span style="font-family: Arial, Helvetica, sans-serif; font-size: 12px; line-height: 16px; background-color: rgb(255, 255, 255);"></span>&nbsp; &nbsp;2 或者直接用JMH的<span style="font-size: 12.5px;">archetype创建：</span></p><pre class="brush:java;toolbar: true; auto-links: false;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mvn&nbsp;archetype:generate&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-DinteractiveMode=false&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-DarchetypeGroupId=org.openjdk.jmh&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-DarchetypeArtifactId=jmh-java-benchmark-archetype&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-DgroupId=com.yao&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-DartifactId=jmh-demo&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Dversion=1.0</pre><p></p><p><span style="font-size: 12.5px;"></span>&nbsp; 环境搭建好之后然后就可以写相应的测试用例了</p><p>&nbsp; Demo如下</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;JMHSample_01_HelloWorld&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;@Benchmark
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;wellHelloThere()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;method&nbsp;was&nbsp;intentionally&nbsp;left&nbsp;blank.
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;a)&nbsp;Via&nbsp;command-line:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;mvn&nbsp;clean&nbsp;install
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;java&nbsp;-jar&nbsp;target/benchmarks.jar&nbsp;JMHSample_01
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;JMH&nbsp;generates&nbsp;self-contained&nbsp;JARs,&nbsp;bundling&nbsp;JMH&nbsp;together&nbsp;with&nbsp;it.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;The&nbsp;runtime&nbsp;options&nbsp;for&nbsp;the&nbsp;JMH&nbsp;are&nbsp;available&nbsp;with&nbsp;"-h":
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;java&nbsp;-jar&nbsp;target/benchmarks.jar&nbsp;-h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;b)&nbsp;Via&nbsp;the&nbsp;Java&nbsp;API:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;(see&nbsp;the&nbsp;JMH&nbsp;homepage&nbsp;for&nbsp;possible&nbsp;caveats&nbsp;when&nbsp;running&nbsp;from&nbsp;IDE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://openjdk.java.net/projects/code-tools/jmh/)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;RunnerException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Options&nbsp;opt&nbsp;=&nbsp;new&nbsp;OptionsBuilder()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.include(JMHSample_01_HelloWorld.class.getSimpleName())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.forks(1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.build();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Runner(opt).run();
&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p></p><p>运行上面的Demo有两种方法：一个是直接打包，然后会在target中生成benchmarks.jar,里面带有main方法，就直接可以运行：java -jar target/benchmarks.jar。运行后的结果如下格式：（运行的结果也写入指定的文件）</p><pre class="brush:java;toolbar: true; auto-links: false;">Result&nbsp;"wellHelloThere":

&nbsp;&nbsp;3142305096.924&nbsp;±(99.9%)&nbsp;17949665.603&nbsp;ops/s&nbsp;[Average]
&nbsp;&nbsp;&nbsp;&nbsp;(min,&nbsp;avg,&nbsp;max)&nbsp;=&nbsp;(2907217981.526,&nbsp;3142305096.924,&nbsp;3226536099.659),&nbsp;stdev&nbsp;=&nbsp;76000008.112
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CI&nbsp;(99.9%):&nbsp;[3124355431.320,&nbsp;3160254762.527]&nbsp;(assumes&nbsp;normal&nbsp;distribution)


#&nbsp;Run&nbsp;complete.&nbsp;Total&nbsp;time:&nbsp;00:06:42
&nbsp;&nbsp;Benchmark&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mode&nbsp;&nbsp;Cnt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Score&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error&nbsp;&nbsp;Units
&nbsp;&nbsp;MyBenchmark.testMethod&nbsp;&nbsp;thrpt&nbsp;&nbsp;200&nbsp;&nbsp;3142305096.924&nbsp;±&nbsp;17949665.603&nbsp;&nbsp;ops/s</pre><p></p><p>同时也支持在IDE中直接运行。</p><p>往往在写用例的时候，可以不写main方法，直接在方法上写个Junit的Test注解 ，功能和main相同。</p><p>比如netty5中为所有的benchmarks写了一个基类如下：</p><pre class="brush:java;toolbar: true; auto-links: false;">@Warmup(iterations&nbsp;=&nbsp;AbstractMicrobenchmark.DEFAULT_WARMUP_ITERATIONS)
@Measurement(iterations&nbsp;=&nbsp;AbstractMicrobenchmark.DEFAULT_MEASURE_ITERATIONS)
@Fork(AbstractMicrobenchmark.DEFAULT_FORKS)
@State(Scope.Thread)
public&nbsp;class&nbsp;AbstractMicrobenchmark&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;static&nbsp;final&nbsp;int&nbsp;DEFAULT_WARMUP_ITERATIONS&nbsp;=&nbsp;10;
&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;static&nbsp;final&nbsp;int&nbsp;DEFAULT_MEASURE_ITERATIONS&nbsp;=&nbsp;10;
&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;static&nbsp;final&nbsp;int&nbsp;DEFAULT_FORKS&nbsp;=&nbsp;2;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;final&nbsp;class&nbsp;HarnessExecutor&nbsp;extends&nbsp;ThreadPoolExecutor&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;HarnessExecutor(int&nbsp;maxThreads,&nbsp;String&nbsp;prefix)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(0,&nbsp;maxThreads,&nbsp;1L,&nbsp;TimeUnit.DAYS,&nbsp;new&nbsp;SynchronousQueue&lt;Runnable&gt;(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;DefaultThreadFactory(prefix));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Using&nbsp;harness&nbsp;executor");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;static&nbsp;final&nbsp;String[]&nbsp;JVM_ARGS&nbsp;=&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"-server",&nbsp;"-dsa",&nbsp;"-da",&nbsp;"-ea:io.netty...",&nbsp;"-Xms768m",&nbsp;"-Xmx768m",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"-XX:MaxDirectMemorySize=768m",&nbsp;"-XX:+AggressiveOpts",&nbsp;"-XX:+UseBiasedLocking",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"-XX:+UseFastAccessorMethods",&nbsp;"-XX:+UseStringCache",&nbsp;"-XX:+OptimizeStringConcat",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"-XX:+HeapDumpOnOutOfMemoryError",&nbsp;"-Dio.netty.noResourceLeakDetection",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"-Dharness.executor=CUSTOM",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"-Dharness.executor.class=io.netty.microbench.util.AbstractMicrobenchmark$HarnessExecutor"
&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.DISABLED);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;@Test
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;throws&nbsp;Exception&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;className&nbsp;=&nbsp;getClass().getSimpleName();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChainedOptionsBuilder&nbsp;runnerOptions&nbsp;=&nbsp;new&nbsp;OptionsBuilder()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.include(".*"&nbsp;+&nbsp;className&nbsp;+&nbsp;".*")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.jvmArgs(JVM_ARGS);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(getWarmupIterations()&nbsp;&gt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runnerOptions.warmupIterations(getWarmupIterations());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(getMeasureIterations()&nbsp;&gt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runnerOptions.measurementIterations(getMeasureIterations());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(getForks()&nbsp;&gt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runnerOptions.forks(getForks());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(getReportDir()&nbsp;!=&nbsp;null)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;filePath&nbsp;=&nbsp;getReportDir()&nbsp;+&nbsp;className&nbsp;+&nbsp;".json";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;file&nbsp;=&nbsp;new&nbsp;File(filePath);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(file.exists())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.delete();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.getParentFile().mkdirs();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.createNewFile();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runnerOptions.resultFormat(ResultFormatType.JSON);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runnerOptions.result(filePath);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Runner(runnerOptions.build()).run();
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;int&nbsp;getWarmupIterations()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;SystemPropertyUtil.getInt("warmupIterations",&nbsp;-1);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;int&nbsp;getMeasureIterations()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;SystemPropertyUtil.getInt("measureIterations",&nbsp;-1);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;int&nbsp;getForks()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;SystemPropertyUtil.getInt("forks",&nbsp;-1);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;String&nbsp;getReportDir()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;SystemPropertyUtil.get("perfReportDir");
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;我这里仅仅是入门性的介绍，具体的参数和用法本人也不是很熟悉。</p><p>具体介绍和用法参照：<a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_self" rel="nofollow">http://openjdk.java.net/projects/code-tools/jmh/</a></p><p>本人通过官网摘抄的例子，传到github上了：<a href="https://github.com/WangErXiao/jmh-demo" target="_blank" rel="nofollow">https://github.com/WangErXiao/jmh-demo</a></p><p>END-----------------------------------------------------------------------------------------</p><p>转发标注来源：<a href="http://my.oschina.net/robinyao/blog/408285" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/408285</a></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_407469" href="http://my.oschina.net/robinyao/blog/407469">Netty ByteBuf详解</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-28 23:31:09</div>
	  <div class='catalog'>分类：netty</div>
	  	  	  <div class='tags'>标签：netty,ByteBuf,NIO,java</div>	  	  	  </div>
      <div class='content'><p>&nbsp;&nbsp;&nbsp;&nbsp;本文主要介绍Netty5 &nbsp;ByteBuf原理及具体使用。</p><p><span style="font-size: 12.5px;">&nbsp;&nbsp;&nbsp;&nbsp;基本结构：与NIO ByteBuffer类似，使用ByteBuffer往往需要在读写之间通过flip切换。ByteBuf里维护两个index,一个readerIndex,一个writerIndex;</span><span style="font-size: 12.5px;">readerIndex writerIndex capactiy &nbsp;的三者的关系是：</span></p><p><span style="font-size: 12.5px;">&nbsp;&nbsp;&nbsp;&nbsp;0 &lt;=readerIndex &lt;=writerIndex &lt;= capacity</span></p><p>&nbsp; &nbsp; &nbsp;当往byteBuf写入一个byte时，writerIndex++,从bytebuf读一个byte时，readerIndex++;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p><pre class="brush:java;toolbar: true; auto-links: false;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+------------------+------------------+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;discardable&nbsp;bytes&nbsp;|&nbsp;&nbsp;readable&nbsp;bytes&nbsp;&nbsp;|&nbsp;&nbsp;writable&nbsp;bytes&nbsp;&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(CONTENT)&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+------------------+------------------+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readerIndex&nbsp;&nbsp;&nbsp;&lt;=&nbsp;&nbsp;&nbsp;writerIndex&nbsp;&nbsp;&nbsp;&nbsp;&lt;=&nbsp;&nbsp;&nbsp;&nbsp;capacity</pre><p><br></p><p>基本操作：</p><p>&nbsp; &nbsp; 通过index随机读：</p><pre class="brush:java;toolbar: true; auto-links: false;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBuf&nbsp;byteBuf=&nbsp;Unpooled.buffer();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byteBuf.writeBytes("hello&nbsp;world".getBytes());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println((char)byteBuf.getByte(0));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println((char)byteBuf.getByte(1));</pre><p>&nbsp;支持顺序读：满足readeableBytes&gt;0 (writerIndex - readerIndex )</p><pre class="brush:java;toolbar: true; auto-links: false;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBuf&nbsp;byteBuf=&nbsp;Unpooled.buffer();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byteBuf.writeBytes("hello&nbsp;world".getBytes());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(byteBuf.readableBytes()&gt;0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println((char)byteBuf.readByte());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p>&nbsp;写操作：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 支持单个byte写入，或者直接写入byte数组；可以通过writeIndex设定writerIndex,但是如果</p><p>&nbsp; &nbsp; &nbsp; &nbsp; writerIndex &lt; readerIndex || writerIndex &gt; capacity() 会抛出IndexOutOfBoundsException；</p><pre class="brush:java;toolbar: true; auto-links: false;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBuf&nbsp;byteBuf=&nbsp;Unpooled.buffer(50);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(byteBuf.writableBytes()&gt;10){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byteBuf.writeByte('a');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byteBuf.writerIndex(byteBuf.writerIndex()+10);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("writerIndex:"+byteBuf.writerIndex());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("readerIndex:"+byteBuf.readerIndex());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("index&nbsp;of&nbsp;0&nbsp;is:"+(char)byteBuf.getByte(0));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("index&nbsp;of&nbsp;11&nbsp;is:"+(char)byteBuf.getByte(11));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("index&nbsp;of&nbsp;22&nbsp;is:"+(char)byteBuf.getByte(22));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("index&nbsp;of&nbsp;33&nbsp;is:"+(char)byteBuf.getByte(33));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("index&nbsp;of&nbsp;40&nbsp;is:"+(char)byteBuf.getByte(40));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(new&nbsp;String(byteBuf.array()));</pre><p>&nbsp; &nbsp; discardReadBytes操作：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 把bytebuf中读过的byte抛弃掉，writerIndex置为writerIndex-readerIndex,readerIndex置为0；</p><pre class="brush:java;toolbar: true; auto-links: false;">ByteBuf&nbsp;byteBuf=&nbsp;Unpooled.buffer();
byteBuf.writeBytes("hello&nbsp;world".getBytes());
System.out.println("readerIndex:"&nbsp;+&nbsp;byteBuf.readerIndex());
System.out.println("writerIndex:"&nbsp;+&nbsp;byteBuf.writerIndex());
System.out.println((char)byteBuf.readByte());
System.out.println(new&nbsp;String(byteBuf.array()));
&nbsp;byteBuf.discardReadBytes();
System.out.println("readerIndex:"&nbsp;+&nbsp;byteBuf.readerIndex());
System.out.println("writerIndex:"&nbsp;+&nbsp;byteBuf.writerIndex());
System.out.println(new&nbsp;String(byteBuf.array()));</pre><p>&nbsp; &nbsp; clear mark reset 操作：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; clear把bytebuf 的writerIndex=readerindex=0;</p><p><span style="font-size: 12.5px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark把当前的writerIndex或者readerIndex mark一下，记录到私有变量中</span><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; reset把当前的writerIndex或者readerIndex恢复到mark的index;</p><pre class="brush:java;toolbar: true; auto-links: false;">&nbsp;ByteBuf&nbsp;byteBuf=&nbsp;Unpooled.buffer();
&nbsp;byteBuf.writeBytes("hello&nbsp;world".getBytes());
&nbsp;System.out.println(new&nbsp;String(byteBuf.array()));
&nbsp;System.out.println("readerIndex:"&nbsp;+&nbsp;byteBuf.readerIndex());
&nbsp;System.out.println("writerIndex:"&nbsp;+&nbsp;byteBuf.writerIndex());
&nbsp;&nbsp;&nbsp;byteBuf.clear();
&nbsp;&nbsp;System.out.println("after&nbsp;clear");
&nbsp;&nbsp;System.out.println("readerIndex:"&nbsp;+&nbsp;byteBuf.readerIndex());
&nbsp;&nbsp;System.out.println("writerIndex:"&nbsp;+&nbsp;byteBuf.writerIndex());
&nbsp;&nbsp;System.out.println(new&nbsp;String(byteBuf.array()));
&nbsp;&nbsp;byteBuf.writerIndex(11);
&nbsp;
&nbsp;&nbsp;&nbsp;byteBuf.readByte();
&nbsp;&nbsp;&nbsp;//在index&nbsp;为1时mark&nbsp;，reset之后重新回到mark的地方&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;byteBuf.markReaderIndex();
&nbsp;&nbsp;&nbsp;byteBuf.readByte();
&nbsp;&nbsp;&nbsp;byteBuf.readByte();
&nbsp;&nbsp;&nbsp;byteBuf.resetReaderIndex();
&nbsp;&nbsp;&nbsp;System.out.println("readerIndex:"&nbsp;+&nbsp;byteBuf.readerIndex());</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;Netty中分配ByteBuf有两种方式，一个是Pooled 池化的，一个是Unpooled 非池化的。</p><p>Unpooled类封装了UnpooledByteBufAllocator，用来初始化ByteBuf 包含Heap类型和Direct类型的。</p><p>PooledByteBufAllocator用来分配池化的ByteBuf,重复利用ByteBuf数组，减少分配回收开销。</p><p>同时Buffer模块还提供方便的工具类ByteBufUtil来操作ByteBuf。</p><p><br></p><p>END--------------------------------------------</p><p>转发标注来源：<a href="http://my.oschina.net/robinyao/blog/407469" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/407469</a></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_406544" href="http://my.oschina.net/robinyao/blog/406544">Jetty源码-Continuation</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-26 21:07:23</div>
	  <div class='catalog'>分类：jetty</div>
	  	  	  <div class='tags'>标签：jetty,Continuation,Servlet</div>	  	  	  </div>
      <div class='content'><p>&nbsp;&nbsp;&nbsp;&nbsp;本文主要介绍Jetty 异步的请求。Jetty Contination可以用来处理大量的时间比较长的连接请求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;http异步请求在Servlet3中已经实现，使用十分方便，通过Request获取异步AsyncContext，然后在上面注册自己的异步监听器AsynListener即可。Tomcat7 和Jetty8以上版本等主流的容器都支持Servlet3的异步请求。具体介绍见<a href="http://www.importnew.com/8864.html" target="_blank" rel="nofollow">http://www.importnew.com/8864.html</a>，详细的Demo<a href="https://github.com/WangErXiao/Servlet3-Async" target="_blank" rel="nofollow">https://github.com/WangErXiao/Servlet3-Async</a>。这里不多介绍Servlet3的异步请求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Jetty的异步请求的实现模块主要是Continuation。通过continuation机制，HTTP 请求可以被挂起，超时或者异步事件发生后重新开始。Continuation接口包含两个重要的方法是suspend()和resume()。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当调用<span style="font-size: 12.8000001907349px; line-height: 22.5px;">continuation.suspend()方法时，会把当前servlet的request和相关的response挂起，request的生命周期将被从Servlet.service(ServletRequest, ServletResponse)扩展到容器，response将不会被提交除非有ContinuationThrowable抛出。调用完suspend方法，注册完异步的handler,直接调用return从Servlet.service方法返回，当前的线程就可以去处理其他任务了。</span></p><p><span style="font-size: 12.8000001907349px; line-height: 22.5px;">&nbsp;&nbsp;&nbsp;&nbsp;任务处理完之后，通过注册好的回调方法调用continuation.resume()。重新用原来的request和reponse发起请求，并从request中获取结果，通过response返回。</span></p><p><span style="font-size: 12.8000001907349px; line-height: 22.5px;">&nbsp;&nbsp;&nbsp;&nbsp;下边是具体的Demo代码：</span></p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;SimpleSuspendResumeServlet&nbsp;extends&nbsp;HttpServlet&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;MyAsyncHandler&nbsp;myAsyncHandler;
&nbsp;&nbsp;&nbsp;&nbsp;//初始化异步处理器
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;init()&nbsp;throws&nbsp;ServletException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myAsyncHandler&nbsp;=&nbsp;new&nbsp;MyAsyncHandler()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;register(final&nbsp;MyHandler&nbsp;myHandler)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(new&nbsp;Runnable()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(10000);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置结果，调用resume方法
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myHandler.onMyEvent("complete!");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;e)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).start();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doGet(HttpServletRequest&nbsp;request,&nbsp;HttpServletResponse&nbsp;response)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;ServletException,&nbsp;IOException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;PrintWriter&nbsp;writer&nbsp;=&nbsp;response.getWriter();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Continuation&nbsp;continuation&nbsp;=&nbsp;ContinuationSupport
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.getContinuation(request);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(continuation.isInitial())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendMyFirstResponse(response);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continuation.suspend();&nbsp;//&nbsp;always&nbsp;suspend&nbsp;before&nbsp;registration
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myAsyncHandler.register(new&nbsp;MyHandler()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onMyEvent(Object&nbsp;result)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continuation.setAttribute("results",&nbsp;result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continuation.resume();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;//&nbsp;然后该线程就可以去处理其他任务了
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(continuation.isExpired())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendMyTimeoutResponse(response);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Send&nbsp;the&nbsp;results
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;results&nbsp;=&nbsp;request.getAttribute("results");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(results==null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.getWriter().write("why&nbsp;reach&nbsp;here??");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continuation.resume();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendMyResultResponse(response,&nbsp;results);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;interface&nbsp;MyAsyncHandler&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;register(MyHandler&nbsp;myHandler);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;interface&nbsp;MyHandler&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onMyEvent(Object&nbsp;result);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;sendMyFirstResponse(HttpServletResponse&nbsp;response)&nbsp;throws&nbsp;IOException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.setContentType("text/html");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.getWriter().write("start---------");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.getWriter().flush();
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;sendMyResultResponse(HttpServletResponse&nbsp;response,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;results)&nbsp;throws&nbsp;IOException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.getWriter().write("results:"&nbsp;+&nbsp;results);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.getWriter().flush();

&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;sendMyTimeoutResponse(HttpServletResponse&nbsp;response)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;IOException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.getWriter().write("timeout");
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p></p><p><span style="font-size: 12.8000001907349px; line-height: 22.5px;"></span>&nbsp;&nbsp;&nbsp;&nbsp;上面代码中的Support，是工厂类，用来生成<span style="font-size: 12.8000001907349px; line-height: 22.5px;">Continuation。如果当前容器采用的是Servlet3，返回</span><span style="font-size: 12.5px;">Servlet3Continuation类型的，如果不是返回FauxContinuation类型的。<span style="font-size: 12.8000001907349px; line-height: 22.5px;">Servlet3Continuation顾名思义是借助Servlet3里的异步机制来实现的，底层的具体实现还是由具体的容器实现，tomcat7,jetty8以上版本都实现Servlet3异步请求功能。<span style="font-size: 12.8000001907349px; line-height: 22.5px;">FauxContinuation是<span style="font-size: 12.8000001907349px; line-height: 22.5px;">Continuation阻塞实现方式，主要是针对才非Servlet3的容器，通过ContinuationFilter过滤器，把<span style="font-size: 12.8000001907349px; line-height: 22.5px;">FauxContinuation添加到request属性中：</span></span></span></span></span></p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;void&nbsp;doFilter(ServletRequest&nbsp;request,&nbsp;ServletResponse&nbsp;response,&nbsp;FilterChain&nbsp;chain)&nbsp;throws&nbsp;IOException,&nbsp;ServletException
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_filtered)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continuation&nbsp;c&nbsp;=&nbsp;(Continuation)&nbsp;request.getAttribute(Continuation.ATTRIBUTE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FilteredContinuation&nbsp;fc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_faux&nbsp;&amp;&amp;&nbsp;(c==null&nbsp;||&nbsp;!(c&nbsp;instanceof&nbsp;FauxContinuation)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fc&nbsp;=&nbsp;new&nbsp;FauxContinuation(request);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.setAttribute(Continuation.ATTRIBUTE,fc);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fc=(FilteredContinuation)c;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;complete=false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(!complete)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fc==null&nbsp;||&nbsp;(fc).enter(response))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain.doFilter(request,response);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(ContinuationThrowable&nbsp;e)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug("faux",e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fc==null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fc&nbsp;=&nbsp;(FilteredContinuation)&nbsp;request.getAttribute(Continuation.ATTRIBUTE);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complete=fc==null&nbsp;||&nbsp;(fc).exit();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain.doFilter(request,response);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(ContinuationThrowable&nbsp;e)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug("caught",e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p></p><p><span style="font-size: 12.8000001907349px; line-height: 22.5px;"></span></p><p>END-------------------------------</p><p>转发请标注来源<a href="http://my.oschina.net/robinyao/blog/406544" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/406544</a></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_404687" href="http://my.oschina.net/robinyao/blog/404687">Jetty源码-Server-Connector</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-21 22:55:57</div>
	  <div class='catalog'>分类：jetty</div>
	  	  	  <div class='tags'>标签：jetty,java,connector,ServerConnector</div>	  	  	  </div>
      <div class='content'><p>&nbsp;&nbsp;&nbsp;&nbsp;Jetty Server两个重要的概念一个是Handler,一个是Connector。&nbsp;我们在内嵌Jetty启动应用时往往会通过WebAppContext来设置上下文，WebAppContext就是一个Handler，我们可以通过Server.setHandler()来赋值我们的上下文。本文主要介绍<span style="font-size: 12.5px;">Connector。它的抽象实现类是AbstractConnector，然后</span><span style="font-size: 12.5px;">ServerConnector继承了<span style="font-size: 12.8000001907349px;">AbstractConnector,这也是重点要介绍的两个类。连接器故名思议主要是用来处理各种类型的请求包括HTTP, HTTP/2 ，WebSocket等等。Jetty 9采用NIO来处理请求，去掉了BIO模块。</span></span></p><p><span style="font-size: 12.5px;"><span style="font-size: 12.8000001907349px; line-height: 22.5px;">&nbsp;&nbsp;&nbsp;&nbsp;下边先贴出一段实用的Jetty内嵌启动代码，方便我们理解Handler和Connector。采用的是9.3版本的jetty jar</span></span></p><pre class="brush:java;toolbar: true; auto-links: false;">/**&nbsp;jetty&nbsp;pom
&lt;dependency&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;jetty-server&lt;/artifactId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;9.3.0.M0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;9.3.0.M0&lt;/version&gt;
&lt;/dependency&gt;
**/

//内嵌代码------------------

Server&nbsp;server&nbsp;=&nbsp;new&nbsp;Server();
//&nbsp;connector
ServerConnector&nbsp;connector&nbsp;=&nbsp;new&nbsp;ServerConnector(server);
connector.setPort(port);
server.setConnectors(new&nbsp;Connector[]&nbsp;{&nbsp;connector&nbsp;});
//context
WebAppContext&nbsp;context&nbsp;=&nbsp;new&nbsp;WebAppContext();
context.setContextPath("/");
//设定webapp,具体的路径根据自己应用来调整
context.setResourceBase("./src/main/webapp");
context.setClassLoader(Thread.currentThread().getContextClassLoader());
context.setParentLoaderPriority(true);
server.setHandler(context);
server.start();
server.join();
//-----------------------------------------</pre><p><span style="font-size: 12.5px;"><span style="font-size: 12.8000001907349px; line-height: 22.5px;"></span></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size: 12.8000001907349px; line-height: 22.5px;">AbstractConnector是Connector的实现类，它提供了ConnectionFactory机制来创建各种协议（HTTP, SSL）的实例。<span style="font-size: 12.8000001907349px; line-height: 22.5px;">AbstractConnector封装了几个重要的属性：</span></span></p><p><span style="font-size: 12.8000001907349px; line-height: 22.5px;"><span style="font-size: 12.8000001907349px; line-height: 22.5px;">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executor:线程池，用来处理接收的连接；</span></span></p><p><span style="font-size: 12.8000001907349px; line-height: 22.5px;"><span style="font-size: 12.8000001907349px; line-height: 22.5px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scheduler：用来监视连接的超时；</span></span></p><p><span style="font-size: 12.8000001907349px; line-height: 22.5px;"><span style="font-size: 12.8000001907349px; line-height: 22.5px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBufferPool：ByteBuffer缓冲池，减少对ByteBuffer的创建开销，循环利用ByteBuffer;</span></span></p><p><span style="font-size: 12.8000001907349px; line-height: 22.5px;"><span style="font-size: 12.8000001907349px; line-height: 22.5px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConnectionFactory: 创建各种协议的工厂，包含&nbsp;SslConnectionFactory，HttpConnectionFactory等等；</span></span></p><p><span style="font-size: 12.8000001907349px; line-height: 22.5px;"><span style="font-size: 12.8000001907349px; line-height: 22.5px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acceptors：来创建接收器的，监听端口过来的请求。<span style="font-size: 12.8000001907349px; line-height: 22.5px;">AbstractConnector</span>里面&nbsp;有个&nbsp;final Thread[] _acceptors&nbsp;&nbsp;变量&nbsp;，这个变量是个线程数组，个数代表你需要创建并发的接收器，多个接收器调用同一个ServerSocketChannel实例上的accept方法，来实现高效的接收请求。AbstractConnector在doStart方法中初始化Acceptor。</span></span></p><pre class="brush:java;toolbar: true; auto-links: false;">protected&nbsp;void&nbsp;doStart()&nbsp;throws&nbsp;Exception
{
&nbsp;&nbsp;&nbsp;&nbsp;_defaultConnectionFactory&nbsp;=&nbsp;getConnectionFactory(_defaultProtocol);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;_stopping=new&nbsp;CountDownLatch(_acceptors.length);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;_acceptors.length;&nbsp;i++)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acceptor&nbsp;a&nbsp;=&nbsp;new&nbsp;Acceptor(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addBean(a);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getExecutor().execute(a);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//初始化Acceptor就直接放到线程池去执行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><span style="font-size: 12.8000001907349px; line-height: 22.5px;"><span style="font-size: 12.8000001907349px; line-height: 22.5px;"></span></span>&nbsp;&nbsp;&nbsp;&nbsp;下边我们分析一下Acceptor这个AbstractConnector内部类：</p><pre class="brush:java;toolbar: true; auto-links: false;">private&nbsp;class&nbsp;Acceptor&nbsp;implements&nbsp;Runnable
{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;_id;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;_name;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Acceptor(int&nbsp;id)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_id&nbsp;=&nbsp;id;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//刚刚我们把它放到线程池里，它会取当前执行它的线程放到AbstractConnector中的_acceptors线程数组中
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//主要是来判断acceptor是否都停掉&nbsp;_stopping=new&nbsp;CountDownLatch(_acceptors.length)。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Thread&nbsp;thread&nbsp;=&nbsp;Thread.currentThread();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name=thread.getName();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_name=String.format("%s-acceptor-%d@%x-%s",name,_id,hashCode(),AbstractConnector.this.toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread.setName(_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;priority=thread.getPriority();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_acceptorPriorityDelta!=0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread.setPriority(Math.max(Thread.MIN_PRIORITY,Math.min(Thread.MAX_PRIORITY,priority+_acceptorPriorityDelta)));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(AbstractConnector.this)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_acceptors[_id]&nbsp;=&nbsp;thread;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(isAccepting())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//！！！这是个抽象方法由具体的实现类ServerConnector来实现。！！！
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accept(_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Throwable&nbsp;e)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isAccepting())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG.warn(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG.ignore(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread.setName(name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_acceptorPriorityDelta!=0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread.setPriority(priority);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(AbstractConnector.this)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_acceptors[_id]&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CountDownLatch&nbsp;stopping=_stopping;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(stopping!=null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopping.countDown();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;toString()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name=_name;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(name==null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;String.format("acceptor-%d@%x",&nbsp;_id,&nbsp;hashCode());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
}</pre><p>&nbsp;下边我们具体介绍accept方法在ServerConnector中的具体实现，ServerConnector有两个重要的方法 open和accept</p><p>下边是具体的代码：</p><pre class="brush:java;toolbar: true; auto-links: false;">//主要是初始化ServerSocketChannel,绑定监听端口。剩下的接收请求交给accept方法来做。
public&nbsp;void&nbsp;open()&nbsp;throws&nbsp;IOException
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_acceptChannel&nbsp;==&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServerSocketChannel&nbsp;serverChannel&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isInheritChannel())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Channel&nbsp;channel&nbsp;=&nbsp;System.inheritedChannel();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(channel&nbsp;instanceof&nbsp;ServerSocketChannel)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverChannel&nbsp;=&nbsp;(ServerSocketChannel)channel;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(serverChannel&nbsp;==&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverChannel&nbsp;=&nbsp;ServerSocketChannel.open();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InetSocketAddress&nbsp;bindAddress&nbsp;=&nbsp;getHost()&nbsp;==&nbsp;null&nbsp;?&nbsp;new&nbsp;InetSocketAddress(getPort())&nbsp;:&nbsp;new&nbsp;InetSocketAddress(getHost(),&nbsp;getPort());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverChannel.socket().setReuseAddress(getReuseAddress());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverChannel.socket().bind(bindAddress,&nbsp;getAcceptQueueSize());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_localPort&nbsp;=&nbsp;serverChannel.socket().getLocalPort();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_localPort&nbsp;&lt;=&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IOException("Server&nbsp;channel&nbsp;not&nbsp;bound");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addBean(serverChannel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverChannel.configureBlocking(true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addBean(serverChannel);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_acceptChannel&nbsp;=&nbsp;serverChannel;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
//这个方法由AbstractConnector中的accepters调用，并发的处理接收请求。
@Override
public&nbsp;void&nbsp;accept(int&nbsp;acceptorID)&nbsp;throws&nbsp;IOException
{
&nbsp;&nbsp;&nbsp;&nbsp;ServerSocketChannel&nbsp;serverChannel&nbsp;=&nbsp;_acceptChannel;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(serverChannel&nbsp;!=&nbsp;null&nbsp;&amp;&amp;&nbsp;serverChannel.isOpen())
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SocketChannel&nbsp;channel&nbsp;=&nbsp;serverChannel.accept();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accepted(channel);
&nbsp;&nbsp;&nbsp;&nbsp;}
}

private&nbsp;void&nbsp;accepted(SocketChannel&nbsp;channel)&nbsp;throws&nbsp;IOException
{
&nbsp;&nbsp;&nbsp;&nbsp;channel.configureBlocking(false);
&nbsp;&nbsp;&nbsp;&nbsp;Socket&nbsp;socket&nbsp;=&nbsp;channel.socket();
&nbsp;&nbsp;&nbsp;&nbsp;configure(socket);
&nbsp;&nbsp;&nbsp;&nbsp;//交给SelectorManager来对请求过来的Channel处理
&nbsp;&nbsp;&nbsp;&nbsp;_manager.accept(channel);
}

protected&nbsp;void&nbsp;configure(Socket&nbsp;socket)
{
&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//禁掉TCP延迟&nbsp;negle算法
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.setTcpNoDelay(true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_lingerTime&nbsp;&gt;=&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.setSoLinger(true,&nbsp;_lingerTime&nbsp;/&nbsp;1000);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.setSoLinger(false,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(SocketException&nbsp;e)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG.ignore(e);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>&nbsp; &nbsp; &nbsp; &nbsp;Connector就介绍到这里，主要是封装了ServerSocketChannel，在多线程环境下监听过来的请求，转发请求给SelectorManager。</p><p>转发标注来源：<a href="http://my.oschina.net/robinyao/blog/404687" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/404687</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;END------------------------------------------------------------------<br></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_403615" href="http://my.oschina.net/robinyao/blog/403615">Jetty源码-IO-ManagedSelector</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-19 22:16:19</div>
	  <div class='catalog'>分类：jetty</div>
	  	  	  <div class='tags'>标签：jetty,java,NIO</div>	  	  	  </div>
      <div class='content'><p>&nbsp;&nbsp;&nbsp;&nbsp;本文主要介绍Jetty对NIO的封装。<br></p><p>&nbsp; &nbsp; jetty对NIO的的封装主要包含几个重要的类：SelectorManager，ManagedSelector，SelectChannelEndPoint,</p><p>ExecutionStrategy,ExecuteProduceRun。下面对这几个类做详细介绍，及这几个类是如何窜连起来工作，处理IO事件的。</p><p>&nbsp; &nbsp; 在介绍这几个类之前，先介绍Jetty中的LifeCycle，实现了改LifeCycle接口的类我们可以把它当作一个组件（compent）来看待，里面的接口包含了start,stop及对组件状态（isRunning,isStarted,isTopped<span style="font-size: 12.5px;">）的判断，同时我们可以往上面注册某些状态监听方法。</span></p><p>&nbsp; &nbsp; &nbsp;先介绍最重要的类ManagedSelector，封装了JDK NIO中的Selector，它同时实现了Runable接口。&nbsp;ManagedSelector成员变量有一个Selector和任务Queue,该任务队列放置的都是Runnable类型的任务。这Queue很重要，用来盛放通过ManagedSelector.submit方法提交上来的action,<span style="font-size: 12.8000001907349px; line-height: 22.5px;">一般该方法由SelectorManager来调用</span>。主要有三种类型的action:</p><p>&nbsp; &nbsp; 1.Acceptor,用来注册监听类型的Key OP_ACCEPT</p><p>&nbsp; &nbsp; 2.Accept，主要是把SocketChannel注册到selector上，用来读写操作；</p><p>&nbsp; &nbsp; 3.Connect,用来注册Key OP_CONNECT,用来判断连接是否就绪；</p><p>一旦有以上三个任务提交上来，该 selector上的select操作都应该被wakeup。下面贴出三个类型的action与sumit方法,这个三个类型都是ManagedSelector内部类。</p><pre class="brush:java;toolbar: true; auto-links: false;">class&nbsp;Acceptor&nbsp;implements&nbsp;Runnable
{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;ServerSocketChannel&nbsp;_channel;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Acceptor(ServerSocketChannel&nbsp;channel)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this._channel&nbsp;=&nbsp;channel;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectionKey&nbsp;key&nbsp;=&nbsp;_channel.register(_selector,&nbsp;SelectionKey.OP_ACCEPT,&nbsp;null);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(LOG.isDebugEnabled())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG.debug("{}&nbsp;acceptor={}",&nbsp;this,&nbsp;key);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Throwable&nbsp;x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closeNoExceptions(_channel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG.warn(x);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}

class&nbsp;Accept&nbsp;implements&nbsp;Runnable
{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;SocketChannel&nbsp;channel;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;Object&nbsp;attachment;

&nbsp;&nbsp;&nbsp;&nbsp;Accept(SocketChannel&nbsp;channel,&nbsp;Object&nbsp;attachment)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.channel&nbsp;=&nbsp;channel;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.attachment&nbsp;=&nbsp;attachment;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;SelectionKey&nbsp;key&nbsp;=&nbsp;channel.register(_selector,&nbsp;0,&nbsp;attachment);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;submit(new&nbsp;CreateEndPoint(channel,&nbsp;key));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Throwable&nbsp;x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closeNoExceptions(channel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG.debug(x);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
class&nbsp;Connect&nbsp;implements&nbsp;Runnable
{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;AtomicBoolean&nbsp;failed&nbsp;=&nbsp;new&nbsp;AtomicBoolean();
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;SocketChannel&nbsp;channel;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;Object&nbsp;attachment;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;Scheduler.Task&nbsp;timeout;

&nbsp;&nbsp;&nbsp;&nbsp;Connect(SocketChannel&nbsp;channel,&nbsp;Object&nbsp;attachment)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.channel&nbsp;=&nbsp;channel;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.attachment&nbsp;=&nbsp;attachment;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.timeout&nbsp;=&nbsp;ManagedSelector.this._selectorManager.getScheduler().schedule(new&nbsp;ConnectTimeout(this),&nbsp;ManagedSelector.this._selectorManager.getConnectTimeout(),&nbsp;TimeUnit.MILLISECONDS);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel.register(_selector,&nbsp;SelectionKey.OP_CONNECT,&nbsp;this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Throwable&nbsp;x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;failed(x);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;failed(Throwable&nbsp;failure)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(failed.compareAndSet(false,&nbsp;true))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout.cancel();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closeNoExceptions(channel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ManagedSelector.this._selectorManager.connectionFailed(channel,&nbsp;failure,&nbsp;attachment);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}

//submit方法：
public&nbsp;void&nbsp;submit(Runnable&nbsp;change)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(LOG.isDebugEnabled())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG.debug("Queued&nbsp;change&nbsp;{}&nbsp;on&nbsp;{}",&nbsp;change,&nbsp;this);
&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;(SpinLock.Lock&nbsp;lock&nbsp;=&nbsp;_lock.lock())
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//提交action
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_actions.offer(change);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_selecting)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selector&nbsp;selector&nbsp;=&nbsp;_selector;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(selector&nbsp;!=&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//唤醒阻塞的select操作
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selector.wakeup();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;To&nbsp;avoid&nbsp;the&nbsp;extra&nbsp;select&nbsp;wakeup.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_selecting&nbsp;=&nbsp;false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><br></p><p>还有一个重要的成员变量是<span style="font-size: 12.5px;">执行策略类（ExecutionStrategy），该类的作用是jetty对它的注释是：ExecutionStrategy</span><span style="font-size: 12.5px;">执行由Producer生产出的runnable任务，任务执行的策略根据实现的不同，或许在调用线程中直接执行</span><span style="font-size: 12.5px;">或者另起一个新的线程来执行。<span style="font-size: 12.8000001907349px; line-height: 22.5px;">ExecutionStrategy这里调用的生产者就是<span style="font-size: 12.8000001907349px; line-height: 22.5px;">ManagedSelector内部类</span></span></span><span style="font-size: 12.5px;">SelectorProducer,该内部类实现了.Producer接口。下面我们可以看看<span style="font-size: 12.8000001907349px; line-height: 22.5px;">ManagedSelector.</span><span style="font-size: 12.8000001907349px; line-height: 22.5px;">SelectorProducer的实现的一些方法：</span></span></p><pre class="brush:java;toolbar: true; auto-links: false;">//ManagedSelector.SelectorProducer,主要用来生产任务。
private&nbsp;class&nbsp;SelectorProducer&nbsp;implements&nbsp;ExecutionStrategy.Producer{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Set&lt;SelectionKey&gt;&nbsp;_keys&nbsp;=&nbsp;Collections.emptySet();
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Iterator&lt;SelectionKey&gt;&nbsp;_cursor&nbsp;=&nbsp;Collections.emptyIterator();
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Runnable&nbsp;produce()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(true)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//处理选中事件，如果有任务生成直接返回。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//注意这里叫作task,要和action区分开来，不用弄混了，
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//这里的task都是根据selector上的相应的就绪key产生的读/写/连接task。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runnable&nbsp;task&nbsp;=&nbsp;processSelected();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(task&nbsp;!=&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;task;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果没有task产生，从actions中取任务
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//这里返回的action都是实现了Product，不会改变selector上的感兴趣事件。（待确认）
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//交由ExecutionStrategy去执行。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runnable&nbsp;action&nbsp;=&nbsp;runActions();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(action&nbsp;!=&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;action;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//更新相应变化的感兴趣Key
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//select,获取感兴趣的事件。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!select())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Runnable&nbsp;processSelected()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(_cursor.hasNext())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectionKey&nbsp;key&nbsp;=&nbsp;_cursor.next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(key.isValid())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;attachment&nbsp;=&nbsp;key.attachment();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(attachment&nbsp;instanceof&nbsp;SelectableEndPoint)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Try&nbsp;to&nbsp;produce&nbsp;a&nbsp;task
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//会产生读或写任务，或者读写任务。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectableEndPoint&nbsp;selectable&nbsp;=&nbsp;(SelectableEndPoint)attachment;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runnable&nbsp;task&nbsp;=&nbsp;selectable.onSelected();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(task&nbsp;!=&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;task;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(key.isConnectable())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runnable&nbsp;task&nbsp;=&nbsp;processConnect(key,&nbsp;(Connect)attachment);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(task&nbsp;!=&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;task;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(key.isAcceptable())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processAccept(key);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalStateException("key="&nbsp;+&nbsp;key&nbsp;+&nbsp;",&nbsp;att="&nbsp;+&nbsp;attachment&nbsp;+&nbsp;",&nbsp;iOps="&nbsp;+&nbsp;key.interestOps()&nbsp;+&nbsp;",&nbsp;rOps="&nbsp;+&nbsp;key.readyOps());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(CancelledKeyException&nbsp;x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(attachment&nbsp;instanceof&nbsp;org.eclipse.jetty.io.EndPoint)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closeNoExceptions((EndPoint)attachment);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Throwable&nbsp;x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(attachment&nbsp;instanceof&nbsp;org.eclipse.jetty.io.EndPoint)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closeNoExceptions((EndPoint)attachment);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;attachment&nbsp;=&nbsp;key.attachment();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(attachment&nbsp;instanceof&nbsp;EndPoint)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closeNoExceptions((EndPoint)attachment);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Runnable&nbsp;runActions()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//循环处理任务队列中的任务，直到任务完全被处理完。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(true)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runnable&nbsp;action;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;(SpinLock.Lock&nbsp;lock&nbsp;=&nbsp;_lock.lock())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action&nbsp;=&nbsp;_actions.poll();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(action&nbsp;==&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;No&nbsp;more&nbsp;actions,&nbsp;so&nbsp;we&nbsp;need&nbsp;to&nbsp;select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_selecting&nbsp;=&nbsp;true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//***重点***&nbsp;如果是生产者生成的任务，直接返回，交给&nbsp;ExecutionStrategy来执行
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(action&nbsp;instanceof&nbsp;Product)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;action;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Running&nbsp;the&nbsp;change&nbsp;may&nbsp;queue&nbsp;another&nbsp;action.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行任务，或许会产生新的任务入队。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runChange(action);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;runChange(Runnable&nbsp;change)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change.run();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Throwable&nbsp;x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.printStackTrace();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;update()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(SelectionKey&nbsp;key&nbsp;:&nbsp;_keys)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateKey(key);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_keys.clear();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;updateKey(SelectionKey&nbsp;key)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;attachment&nbsp;=&nbsp;key.attachment();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(attachment&nbsp;instanceof&nbsp;SelectableEndPoint)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((SelectableEndPoint)attachment).updateKey();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;//重新进行选择。。。。。。
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;boolean&nbsp;select()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selector&nbsp;selector&nbsp;=&nbsp;_selector;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(selector&nbsp;!=&nbsp;null&nbsp;&amp;&amp;&nbsp;selector.isOpen())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;selected&nbsp;=&nbsp;selector.select();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;(SpinLock.Lock&nbsp;lock&nbsp;=&nbsp;_lock.lock())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;finished&nbsp;selecting
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_selecting&nbsp;=&nbsp;false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_keys&nbsp;=&nbsp;selector.selectedKeys();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_cursor&nbsp;=&nbsp;_keys.iterator();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Throwable&nbsp;x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closeNoExceptions(_selector);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>接着看ManagedSelector里的run()方法，它直接调用_strategy.execute()；这里的ExecutionStrategy具体的execute实现是ExecuteProduceRun。这里不帖代码，篇幅太长了。主要是循环的调用_producer.produce()产生任务，并执行任务；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;最后介绍SelectorManager，主要是用来管理<span style="font-size: 12.8000001907349px; line-height: 22.5px;">ManagedSelector。它主要是保存了对ManagedSelector数组的引用,同时也引用了一个线程池，用来执行<span style="font-size: 12.8000001907349px; line-height: 22.5px;">ManagedSelector。</span>SelectorManager实现了 LifeCycle接口，它在doStart方法中对ManagedSelector数组初始化，并在线程池里执行初始化好的ManagedSelector,具体代码如下：</span></p><pre class="brush:java;toolbar: true; auto-links: false;">protected&nbsp;void&nbsp;doStart()&nbsp;throws&nbsp;Exception
{
&nbsp;&nbsp;&nbsp;&nbsp;super.doStart();
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;_selectors.length;&nbsp;i++)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ManagedSelector&nbsp;selector&nbsp;=&nbsp;newSelector(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_selectors[i]&nbsp;=&nbsp;selector;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selector.start();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;execute(selector);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>&nbsp; &nbsp;还有写地方理解不是很深入，有些地方理解的可能不正确，大家结合源码校验下。。。。。。。待续</p><p>&nbsp;<span style="color: rgb(51, 51, 51); font-family: Verdana, sans-serif, 宋体; font-size: 12.8000001907349px; letter-spacing: 0.5px; line-height: 22.5px; background-color: rgb(255, 255, 255);">转发请标注来源：</span>&nbsp;<a href="http://my.oschina.net/robinyao/blog/403615" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/403615</a></p><p>END-------------------------------</p><p><br></p><p><br></p><p><br></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_403334" href="http://my.oschina.net/robinyao/blog/403334">Jetty源码-IO-BufferBufferPool</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-18 15:10:35</div>
	  <div class='catalog'>分类：jetty</div>
	  	  	  <div class='tags'>标签：Jetty,ByteBuffer,Pool,java</div>	  	  	  </div>
      <div class='content'><p>&nbsp; &nbsp;继续上文<a href="http://my.oschina.net/robinyao/blog/402692" target="_blank" rel="nofollow">Jetty源码-IO-BufferUtil</a> &nbsp;,接着讲解下Jetty ByteBufferPool的实现。<br></p><p>&nbsp; &nbsp;主要介绍ArrayByteBufferPool的实现，大概的原理是用Bucket数据来放要池化的ByteBuffer。桶的结构包含了它要池化ByteBuffer容量的大小Size &nbsp;和 &nbsp;一个Queue （这里采用的是ConcurrentLinkedQueue,线程安全）。一个ByteBufferPool包含了两个Bucket[]，一个用来放direct类型的ByteBuffer,一个用来放Heap类型的ByteBuffer。ByteBufferPool初始化的时候会把两个桶的每个成员都初始化。一个Bucket盛放对应相应capacity大小的的ByteBuffer。比如 我们ByteBufferPool池化可以放置最大容量为1024*60 到最小容量为0的ByteBuffer。对应的Bucket数组初始化就是60个桶，从 1024大小的，2048大小的，3072大小的.....1024*60大小的桶，当我们需要ByteBuffer时，我们只需根据容量到相应的桶中的Queue取出来即可。</p><p>以下是具体代码</p><p>接口类：</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;interface&nbsp;ByteBufferPool&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;获取指定大小的ByteBuffer.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;size
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;direct&nbsp;&nbsp;是否用direct内存
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ByteBuffer&nbsp;acquire(int&nbsp;size,boolean&nbsp;direct);

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;返还ByteBuffer,使之重用
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;release(ByteBuffer&nbsp;buffer);
&nbsp;&nbsp;&nbsp;&nbsp;//ByteBufferPool的工具类，我们可以方便的用它来操作ByteBufferPool,当然不用也可以，大家可以先直接跳过
&nbsp;&nbsp;&nbsp;&nbsp;//因为这个类有点会误导大家的思路。可以直接看ArrayByteBufferPool的实现就OK
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;class&nbsp;Lease{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;ByteBufferPool&nbsp;byteBufferPool;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;List&lt;ByteBuffer&gt;&nbsp;buffers;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;List&lt;Boolean&gt;recycles;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Lease(ByteBufferPool&nbsp;byteBufferPool,&nbsp;List&lt;ByteBuffer&gt;&nbsp;buffers,&nbsp;List&lt;Boolean&gt;&nbsp;recycles)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.byteBufferPool&nbsp;=&nbsp;byteBufferPool;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.buffers&nbsp;=&nbsp;buffers;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.recycles&nbsp;=&nbsp;recycles;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ByteBuffer&nbsp;acquire(int&nbsp;capacity,boolean&nbsp;direct){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBuffer&nbsp;buffer=byteBufferPool.acquire(capacity,direct);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferUtil.clearToFill(buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;buffer;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//预先王ByteBuffer&nbsp;list中插入一个ByteBuffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;prepend(ByteBuffer&nbsp;&nbsp;buffer,boolean&nbsp;recycle){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insert(0,&nbsp;buffer,&nbsp;recycle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insert(int&nbsp;index,&nbsp;ByteBuffer&nbsp;buffer,&nbsp;boolean&nbsp;recycle)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffers.add(index,buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recycles.add(index,recycle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;append(ByteBuffer&nbsp;buffer,&nbsp;boolean&nbsp;recycle)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffers.add(buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recycles.add(recycle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;List&lt;ByteBuffer&gt;&nbsp;getByteBuffers()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;buffers;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//buffer&nbsp;list&nbsp;所有剩余长度
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;long&nbsp;getTotalLength()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;length&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;buffers.size();&nbsp;++i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;+=&nbsp;buffers.get(i).remaining();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;getSize()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;buffers.size();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放所有可以循环利用的ByteBuffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;recycle()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;buffers.size();&nbsp;++i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBuffer&nbsp;buffer&nbsp;=&nbsp;buffers.get(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(recycles.get(i))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byteBufferPool.release(buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffers.clear();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recycles.clear();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>具体的ArrayByteBufferPool的实现</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;ArrayByteBufferPool&nbsp;implements&nbsp;ByteBufferPool&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;_min;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;Bucket[]_direct;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;Bucket[]_indirect;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;_inc;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ArrayByteBufferPool()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this(0,1024,64*1024);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ArrayByteBufferPool(int&nbsp;minSize,&nbsp;int&nbsp;increment,&nbsp;int&nbsp;maxSize)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//最小size不能大于增量
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(minSize&gt;=increment)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException("minSize&nbsp;&gt;=&nbsp;increment");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//最大size&nbsp;必须是增量的整数倍，并且增量不能大于最大的size
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((maxSize%increment)!=0&nbsp;||&nbsp;increment&gt;=maxSize)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException("increment&nbsp;must&nbsp;be&nbsp;a&nbsp;divisor&nbsp;of&nbsp;maxSize");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_min=minSize;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_inc=increment;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//初始化&nbsp;maxSize/increment个桶,包含直接内存的与heap的
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_direct=new&nbsp;Bucket[maxSize/increment];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_indirect=new&nbsp;Bucket[maxSize/increment];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;size=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0;i&lt;_direct.length;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size+=_inc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_direct[i]=new&nbsp;Bucket(size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_indirect[i]=new&nbsp;Bucket(size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ByteBuffer&nbsp;acquire(int&nbsp;size,&nbsp;boolean&nbsp;direct)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//根据size找到对应size的桶
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket&nbsp;bucket&nbsp;=&nbsp;bucketFor(size,direct);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果queue中存在ByteBuffer,则直接返回
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBuffer&nbsp;buffer&nbsp;=&nbsp;bucket==null?null:bucket._queue.poll();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//初次使用&nbsp;桶中的queue没有&nbsp;ByteBuffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer&nbsp;==&nbsp;null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//（bucket==null）如果是由于size&nbsp;超过pool的最大size,造成没有相应的桶
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;capacity&nbsp;=&nbsp;bucket==null?size:bucket._size;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//分配相应size的ByteBuffer;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;=&nbsp;direct&nbsp;?&nbsp;BufferUtil.allocateDirect(capacity)&nbsp;:&nbsp;BufferUtil.allocate(capacity);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;buffer;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;release(ByteBuffer&nbsp;buffer)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer!=null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket&nbsp;bucket&nbsp;=&nbsp;bucketFor(buffer.capacity(),buffer.isDirect());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(bucket!=null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferUtil.clear(buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//关键：这步是把相应size的ByteBuffer放到相应的size的桶中，byteBuffer入队,用来重用
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bucket._queue.offer(buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;//清空byteBuffer&nbsp;&nbsp;pool
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;clear(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0;i&lt;_direct.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_direct[i]._queue.clear();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_indirect[i]._queue.clear();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;//根据size寻找&nbsp;桶
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Bucket&nbsp;bucketFor(int&nbsp;size,boolean&nbsp;direct)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(size&lt;=_min)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;b=(size-1)/_inc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(b&gt;=_direct.length)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket&nbsp;bucket&nbsp;=&nbsp;direct?_direct[b]:_indirect[b];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;bucket;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;class&nbsp;Bucket{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;final&nbsp;int&nbsp;_size;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;final&nbsp;Queue&lt;ByteBuffer&gt;&nbsp;_queue=&nbsp;new&nbsp;ConcurrentLinkedQueue&lt;&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket(int&nbsp;size)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_size=size;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;toString()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;String.format("Bucket@%x{%d,%d}",hashCode(),_size,_queue.size());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>简单的测试：</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;ByteBufferPoolTest&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]args){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBufferPool.Lease&nbsp;lease&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;ByteBufferPool.Lease(new&nbsp;ArrayByteBufferPool(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;ArrayList&lt;&gt;(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;ArrayList&lt;&gt;());


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBuffer&nbsp;buffer1=lease.acquire(100,&nbsp;false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lease.append(buffer1,true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer1.put("robin&nbsp;yao".getBytes());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferUtil.flipToFlush(buffer1,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(new&nbsp;String(buffer1.array()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lease.recycle();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBuffer&nbsp;buffer2=lease.acquire(100,&nbsp;false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//是否是同一个
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(buffer1==buffer2);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>除了ArrayByteBufferPool的实现，还有MappedByteBufferPool的实现，利用ConcurrentMap实现，这里不做介绍</p><p>转发请标注来源：<a href="http://my.oschina.net/robinyao/blog/403334" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/403334</a> &nbsp;</p><p>END-----------------------------------------</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_403215" href="http://my.oschina.net/robinyao/blog/403215">zookeeper Leader Elections</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-17 22:31:21</div>
	  <div class='catalog'>分类：zookeeper</div>
	  	  	  <div class='tags'>标签：zookeeper,java,分布式</div>	  	  	  </div>
      <div class='content'><p>&nbsp; &nbsp; &nbsp;本文主要介绍zookeeper leader选举机制。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp; zookeeper中leader主要处理来至客户端的写请求，包括create、setData、delete等改变数据的状态的写请求。在zookeeper集群中，<span style="font-size: 12.5px;">每一个zookeeper Server节点开始的状态都是LOOKING,它必须选择一个新的Leader，或者找到已经存在的Leader。</span></p><p><span style="font-size: 12.5px;">&nbsp; &nbsp; &nbsp;如果此时，集群中存在 Leader,其他集群的中节点将通知新进入的Server节点哪个是Leader节点，新节点将连接到Leader上，并且同步Leader的状态，使之一致。</span></p><p><span style="font-size: 12.5px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果此时集群不存在Leader,都是LOOKING状态，它们将选举出新的Leader。节点通过相互发送消息，选举出Leader。选举出的节点将进入LEADING状态，其他的节点将进入FOLLOWING状态。<br></span></p><p><span style="font-size: 12.5px;">&nbsp;&nbsp;&nbsp;&nbsp;leader选举消息又被叫作leader选举通知。当一个节点进入LOOKING状态时，它将发送给其他每一个节点通知。通知包含它当前的选举(vote)，由sid (Server Id) 和 zxid(zookeeper事务id,最新的事务id)组成。比如(1,5)通知代表被server id为1，最新事务id为5的节点放送的。<br></span></p><p><span style="font-size: 12.5px;">&nbsp;&nbsp;&nbsp;&nbsp;当收到一个vote通知，节点将根据如下规则改变自己的vote：<br></span></p><p><span style="font-size: 12.5px;">&nbsp;&nbsp;&nbsp;&nbsp;1设定 voteId 和 voteZxid 代表当前节点受到的vote标识，myZxid和mySid代表receiver自己本身的值。<br></span></p><p><span style="font-size: 12.5px;">&nbsp; &nbsp; 2 如果 <span style="font-size: 12.8000001907349px; line-height: 22.5px;">voteZxid</span> &gt; myZxid 或者 (voteZxid==myZxid and voteId &gt; mySid),receiver将保持当前的vote，也就是赞同当前的选举。</span></p><p><span style="font-size: 12.5px;">&nbsp; &nbsp; 3否者，receiver将改变自己的vote, 该vote 为（mySid,myZxid），也就是说我不赞同当前收到的vote,我要自己当领 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导。</span></p><p>简而言之，就是最近发起的vote将会获胜，谁的zxid大，谁获胜，如果zxid相同，就只能比较节点标示id的大小了（同一辈子，嫡长子继承了，哈哈）。紧接着，如果receiver赞同收到的选举，它将向其他节点发送该通知。一旦有一个节点 收到 &nbsp;来至半数 &nbsp;以上的节点 同样的vote（sid,zxid）,该节点就声明LEADER选举出来了。如果LEADER是该节点本身，它将承担起Leader角色的功能。如果不是，它将变为一个Follower，并且连接LEADER,同步leader的状态，然后处理来至客户端的请求。</p><p>&nbsp; 通过如下图详解上述过程，假设集群中有三个节点：<br></p><p><img src="http://static.oschina.net/uploads/space/2015/0417/215502_vcCv_223302.png"></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;第一步：3个节点都将向其他节点 发送各自的选举vote ；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;第二步：通过我们刚才讲的规则，S2 和 S3的zxid比较小，所以它们的vote都变为(1,6)，并且通知其他节点;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步：三个节点 都收到半数以上的对(1,6)选举。所以S1被选为Leader。</p><p>并不是所有的选举过程都像上面的过程那么顺利，往往由于网络delay,会造成不同上述的过程。如下：<img src="http://static.oschina.net/uploads/space/2015/0417/220516_Zghg_223302.png"></p><p>&nbsp; &nbsp; &nbsp;第一步：由于S1 到 S2 网络delay,当S2受到S3的vote(3,5)，并赞同该（3，5），发出通知，选举S3。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp; 第二步：S3受到(1,6),但是由于网络delay,它发出的通知到S1比较慢，而此时，S3已经有半数的投票了。所以S3被选为Leader。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;第三步：S1接到S3的投票，S1也有半数以上的投票，S1也被选为Leader。<br></p><p>这样会怎么办呢？？ &nbsp;在第二步的时候S3不响应S2提出选自己作为Leader,因为自己vote已经变为(1,6)了，所以S3不会相应S2提出自己作为Leader的要求。所有S2会等待超时，最终S1成为Leader。&nbsp;</p><p>&nbsp; 这只是一种延时的例子，还有很多其他例子，就不一一列举了。</p><p>&nbsp;该文章内容参照：<span style="color: rgb(102, 102, 102); font-family: arial, 'microsoft yahei'; font-size: 16px; font-weight: 600; line-height: 1.5em; background-color: rgb(255, 255, 255);">ZooKeeper: Distributed Process Coordination 这本书。</span></p><p>&nbsp;转发请标注来源：<a href="http://my.oschina.net/robinyao/blog/403215" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/403215</a></p><p>END----------------------------------------------------------------------</p><p><br></p><p><span style="font-size: 12.5px;">&nbsp; <br></span></p><p>&nbsp; &nbsp; &nbsp;</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_402692" href="http://my.oschina.net/robinyao/blog/402692">Jetty源码-IO-BufferUtil</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-16 23:33:41</div>
	  <div class='catalog'>分类：jetty</div>
	  	  	  	  	  </div>
      <div class='content'><p>&nbsp;&nbsp;&nbsp;&nbsp;jetty 源码 BufferUtil 工具类主要是封装了对JDK ByteBuffer的操作。通过BufferUtil可以更容易的操作ByteBuffer.<br></p><p>由于ByteBuffer分为fill模式即写模式、flush模式即读模式，我们经常会在读写之间把ByteBuffer的状态搞混，经常忘记调用flip()等等，而且代码不容易理解。以后我们可以把jetty提供的BufferUitl引入作为工具类，很方便的操作ByteBuffer。如下示例：</p><pre class="brush:java;toolbar: true; auto-links: false;">&nbsp;//置为写模式
&nbsp;&nbsp;int&nbsp;pos&nbsp;=&nbsp;BufferUtil.flipToFill(buffer);
&nbsp;&nbsp;try
&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//写入数据
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.put(data);
&nbsp;&nbsp;}
&nbsp;&nbsp;finally
&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//置为读模式
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flipToFlush(buffer,&nbsp;pos);
&nbsp;&nbsp;}</pre><p></p><p>下面是贴出的部分BufferUitl代码，及个人的注释：</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;BufferUtil&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;分配flush模式的ByteBuffer，limit和position都为0,在写入数据时，必须先翻为fill模式
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;capacity
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;ByteBuffer&nbsp;allocate(int&nbsp;capacity)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBuffer&nbsp;buf&nbsp;=&nbsp;ByteBuffer.allocate(capacity);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.limit(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;buf;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;ByteBuffer&nbsp;allocateDirect(int&nbsp;capacity)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBuffer&nbsp;buf&nbsp;=&nbsp;ByteBuffer.allocateDirect(capacity);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.limit(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;buf;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;清空buffer&nbsp;,只需把positoin&nbsp;和limit&nbsp;同时置为0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;clear(ByteBuffer&nbsp;buffer)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer&nbsp;!=&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.position(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.limit(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;清空buffer&nbsp;,置为fill模式
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;clearToFill(ByteBuffer&nbsp;buffer)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer&nbsp;!=&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.position(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.limit(buffer.capacity());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;翻转为fill模式
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;int&nbsp;flipToFill(ByteBuffer&nbsp;buffer)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;position&nbsp;=&nbsp;buffer.position();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;limit&nbsp;=&nbsp;buffer.limit();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//说明正好flush完，可以完全转换未fill模式
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(position&nbsp;==&nbsp;limit)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.position(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.limit(buffer.capacity());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//当前limit&nbsp;equal&nbsp;capacity,另申请空间
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;capacity&nbsp;=&nbsp;buffer.capacity();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(limit&nbsp;==&nbsp;capacity)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.compact();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//一般情况，剩余的容量，可写的空间
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.position(limit);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.limit(capacity);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;position;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;转为flush模式，即读模式，把当前写到的位置至为limit,动态传入读开始位置position,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;如果position未0&nbsp;,该方法的作用和&nbsp;ByteBuffer.flip()的作用等价
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;flipToFlush(ByteBuffer&nbsp;buffer,&nbsp;int&nbsp;position)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.limit(buffer.position());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.position(position);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;把buffer转换为数组。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;byte[]&nbsp;toArray(ByteBuffer&nbsp;buffer)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//主要针对heap&nbsp;buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer.hasArray())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]&nbsp;array&nbsp;=&nbsp;buffer.array();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;from=buffer.arrayOffset()&nbsp;+&nbsp;buffer.position();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Arrays.copyOfRange(array,&nbsp;from,&nbsp;from&nbsp;+&nbsp;buffer.remaining());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//针对&nbsp;direct&nbsp;buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]&nbsp;to&nbsp;=&nbsp;new&nbsp;byte[buffer.remaining()];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.slice().get(to);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;to;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;是否为空&nbsp;，remaining()&nbsp;主要是&nbsp;&nbsp;limit&nbsp;-&nbsp;position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;buf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;boolean&nbsp;isEmpty(ByteBuffer&nbsp;buf)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;buf&nbsp;==&nbsp;null&nbsp;||&nbsp;buf.remaining()&nbsp;==&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;boolean&nbsp;hasContent(ByteBuffer&nbsp;buf)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;buf&nbsp;!=&nbsp;null&nbsp;&amp;&amp;&nbsp;buf.remaining()&nbsp;&gt;&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;boolean&nbsp;isFull(ByteBuffer&nbsp;buf)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;buf&nbsp;!=&nbsp;null&nbsp;&amp;&amp;&nbsp;buf.limit()&nbsp;==&nbsp;buf.capacity();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;int&nbsp;length(ByteBuffer&nbsp;buffer)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;buffer&nbsp;==&nbsp;null&nbsp;?&nbsp;0&nbsp;:&nbsp;buffer.remaining();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;int&nbsp;space(ByteBuffer&nbsp;buffer)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer&nbsp;==&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;buffer.capacity()&nbsp;-&nbsp;buffer.limit();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;boolean&nbsp;compact(ByteBuffer&nbsp;buffer)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer.position()==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;full&nbsp;=&nbsp;buffer.limit()&nbsp;==&nbsp;buffer.capacity();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.compact().flip();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;full&nbsp;&amp;&amp;&nbsp;buffer.limit()&nbsp;&lt;&nbsp;buffer.capacity();
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;把from中未读的，写到&nbsp;to&nbsp;中
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;from&nbsp;Buffer&nbsp;&nbsp;读模式&nbsp;&nbsp;flush
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;to&nbsp;&nbsp;&nbsp;Buffer&nbsp;&nbsp;写模式&nbsp;&nbsp;fill
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;number&nbsp;of&nbsp;bytes&nbsp;moved
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;int&nbsp;put(ByteBuffer&nbsp;from,&nbsp;ByteBuffer&nbsp;to)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;put;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;remaining&nbsp;=&nbsp;from.remaining();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(remaining&nbsp;&gt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;//如果空间足够，直接写入
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(remaining&nbsp;&lt;=&nbsp;to.remaining())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to.put(from);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put&nbsp;=&nbsp;remaining;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//把from&nbsp;读完
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from.position(from.limit());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//heap&nbsp;buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(from.hasArray())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put&nbsp;=&nbsp;to.remaining();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//只读部分数据
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to.put(from.array(),&nbsp;from.arrayOffset()&nbsp;+&nbsp;from.position(),&nbsp;put);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from.position(from.position()&nbsp;+&nbsp;put);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//direct&nbsp;buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//只读部分数据
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put&nbsp;=&nbsp;to.remaining();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBuffer&nbsp;slice&nbsp;=&nbsp;from.slice();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slice.limit(put);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to.put(slice);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from.position(from.position()&nbsp;+&nbsp;put);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put&nbsp;=&nbsp;0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;put;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;添加&nbsp;byte[]&nbsp;到buffer中
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;b
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;off
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;len
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@throws&nbsp;java.nio.BufferOverflowException
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;append(ByteBuffer&nbsp;to,&nbsp;byte[]&nbsp;b,&nbsp;int&nbsp;off,&nbsp;int&nbsp;len)&nbsp;throws&nbsp;BufferOverflowException
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;//置为写模式
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;pos&nbsp;=&nbsp;flipToFill(to);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to.put(b,&nbsp;off,&nbsp;len);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//置为读模式
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flipToFlush(to,&nbsp;pos);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;从文件中读数据到buffer中
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@throws&nbsp;IOException
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;readFrom(File&nbsp;file,&nbsp;ByteBuffer&nbsp;buffer)&nbsp;throws&nbsp;IOException
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try(RandomAccessFile&nbsp;raf&nbsp;=&nbsp;new&nbsp;RandomAccessFile(file,"r"))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileChannel&nbsp;channel&nbsp;=&nbsp;raf.getChannel();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;needed=raf.length();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(needed&gt;0&nbsp;&amp;&amp;&nbsp;buffer.hasRemaining())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;needed=needed-channel.read(buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;readFrom(InputStream&nbsp;is,&nbsp;int&nbsp;needed,&nbsp;ByteBuffer&nbsp;buffer)&nbsp;throws&nbsp;IOException
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteBuffer&nbsp;tmp&nbsp;=&nbsp;allocate(8192);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(needed&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;buffer.hasRemaining())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;l&nbsp;=&nbsp;is.read(tmp.array(),&nbsp;0,&nbsp;8192);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp.position(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp.limit(l);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.put(tmp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p></p><p>转载请表明来源：<a href="http://my.oschina.net/robinyao/blog/402692" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/402692</a> &nbsp;</p><p>END------------------------------------------</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_402068" href="http://my.oschina.net/robinyao/blog/402068">shell编写图片爬虫</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-15 20:38:43</div>
	  <div class='catalog'>分类：shell</div>
	  	  	  	  	  </div>
      <div class='content'><p>&nbsp;&nbsp;&nbsp;&nbsp;本例子来源于Linux shell Scripting Cookbook,自己简单注释下；</p><pre class="brush:shell;toolbar: true; auto-links: false;">#!/bin/bash
#Description:&nbsp;Images&nbsp;downloader
#Filename:&nbsp;img_downloader.sh
#&nbsp;校验参数个数&nbsp;$#&nbsp;代表参数个数，&nbsp;$0代表当前文件名称
if&nbsp;[&nbsp;$#&nbsp;-ne&nbsp;3&nbsp;]
then
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"Usage:&nbsp;$0&nbsp;URL&nbsp;-d&nbsp;DIRECTORY"
&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;-1
fi
#循环解析参数
#也可以写成while格式的
#使用shift操作，直至参数不为空为止
#while&nbsp;[&nbsp;-n&nbsp;"$0"]
#do
#case&nbsp;$1&nbsp;in
#&nbsp;-d)&nbsp;shift;directory=$1;shift;;
#&nbsp;&nbsp;*)&nbsp;url=$1;shift;;
#esac
#done
for&nbsp;i&nbsp;in&nbsp;{&nbsp;1..4}
do
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;$1&nbsp;in&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;-d)&nbsp;shift;&nbsp;directory=$1;&nbsp;shift&nbsp;;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)&nbsp;url=${url:-$1};&nbsp;shift;;

esac
done

mkdir&nbsp;-p&nbsp;$directory;
#通过正则表达式，把传入的含有url的String，截取未标准的Url
baseurl=$(echo&nbsp;$url&nbsp;|&nbsp;egrep&nbsp;-o&nbsp;"https?://[a-z.]+")
#curl&nbsp;-s&nbsp;获取url内容，并且不打印提示信息
curl&nbsp;-s&nbsp;$url&nbsp;|&nbsp;egrep&nbsp;-o&nbsp;"&lt;img&nbsp;src=[^&gt;]*&gt;"&nbsp;|
sed&nbsp;'s/&lt;img&nbsp;src=\"\([^"]*\).*/\1/g'&nbsp;&gt;&nbsp;/tmp/$$.list
sed&nbsp;-i&nbsp;"s|^/|$baseurl/|"&nbsp;/tmp/$$.list
cd&nbsp;$directory;
while&nbsp;read&nbsp;filename;
do
&nbsp;&nbsp;curl&nbsp;-s&nbsp;-O&nbsp;"$filename"&nbsp;--silent
done&nbsp;&lt;/tmp/$$.list</pre><p></p><p>&nbsp; &nbsp;这里具体讲解下</p><pre class="brush:shell;toolbar: true; auto-links: false;">egrep&nbsp;-o&nbsp;"&lt;img&nbsp;src=[^&gt;]*&gt;"</pre><p></p><p>&nbsp; &nbsp;egrep 相当与 grep -e 后面可以用正则表达式来索引内容。[^&gt;]* 表示一直到不为 '&gt;'的前面的所有的内容。这一步主要是把&lt;img src="xxx" &nbsp;.. &nbsp;&gt;这中内容提取出来。</p><pre class="brush:shell;toolbar: true; auto-links: false;">sed&nbsp;'s/&lt;img&nbsp;src=\"\([^"]*\).*/\1/g'&nbsp;&gt;&nbsp;/tmp/$$.list</pre><p></p><p>&nbsp; &nbsp;sed 后面跟的正则表达式格式 一般是 's/ \( \) /\1/g' ，其中 \1代表是前面第一个匹配上的正则表达式的引用，如果有多个就可以写成 's/\( \) &nbsp;\( &nbsp;\)/\1 \2/g' ，比如我们想把两个字母翻转 可以写成&nbsp;echo 'ab' | sed 's/\(.\)\(.\)/\2\1/' 。</p><p>$$代表当前进程的id。把得到的结果放到$$.list中。</p><pre class="brush:shell;toolbar: true; auto-links: false;">sed&nbsp;-i&nbsp;"s|^/|$baseurl/|"&nbsp;/tmp/$$.list</pre><p></p><p>&nbsp; &nbsp;这句话的作用是把那些图片中以相对路径 '/'开头 替换成当前的上下文。</p><pre class="brush:shell;toolbar: true; auto-links: false;">while&nbsp;read&nbsp;filename;
do
&nbsp;&nbsp;curl&nbsp;-s&nbsp;-O&nbsp;"$filename"&nbsp;--silent
done&nbsp;&lt;/tmp/$$.list</pre><p></p><p>&nbsp; &nbsp;把$$.list中的url按行读到filename中，curl 后面跟的是-O 不是0。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;转发标注来源 &nbsp;<a href="http://my.oschina.net/robinyao/blog/402068" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/402068</a></p><p>&nbsp; &nbsp;END----------------------------------</p><p><br></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_400712" href="http://my.oschina.net/robinyao/blog/400712">Jetty源码-自旋锁的实现</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-13 20:29:29</div>
	  <div class='catalog'>分类：jetty</div>
	  	  	  <div class='tags'>标签：jetty,自旋锁,spinlock,java</div>	  	  	  </div>
      <div class='content'><p>&nbsp; &nbsp; &nbsp; 最近在浏览jetty9.3的源码，具体代码见github &nbsp;<a href="https://github.com/eclipse/jetty.project" target="_blank" rel="nofollow">https://github.com/eclipse/jetty.project</a></p><p>&nbsp; &nbsp; &nbsp; 本篇文章主要介绍jetty源码中 jetty-util模块的线程部分中自旋锁。jetty线程模块中，线程池的实现没有什么特别的部分，都是对JDK中ThreadPoolExecutor的封装。其中有个自旋锁的实现，个人感觉挺好的。</p><p>&nbsp; &nbsp; &nbsp; 在介绍之前，先介绍JDK1.7引入的一个AutoCloseable接口，本人也是初次才知道这个接口。该接口的作用主要是凡是实现了该接口的类，通过可以在try(){}-catch语法里，自动调用释放资源的方法close()。以下是具体的Demo</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;TestAutoClose&nbsp;implements&nbsp;AutoCloseable&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;method(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("invoke&nbsp;method............");
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;close()&nbsp;throws&nbsp;Exception&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("close&nbsp;resource.............");
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]args){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try(TestAutoClose&nbsp;testAutoClose=new&nbsp;TestAutoClose()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testAutoClose.method();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//程序会自动调用close()方法，我们可以在里面实现释放资源的逻辑
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p></p><p>&nbsp; &nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 现在步入正题jetty SpinLock:</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 该自旋锁设计目的主要是为了保护非常短小的关键代码段。线程在获取到该自旋锁之前会一直自旋，<span style="font-size: 12.5px;">&nbsp;因此被该自旋锁保护的代码，必须非常简单，没有阻塞。因为在各个线程竞争获取该锁的时候，</span><span style="font-size: 12.5px;">&nbsp;会一直自旋，不会放弃cpu,</span><span style="font-size: 12.5px;">&nbsp;该锁主要通过原子类的CAS，来获取锁。</span></p><p><span style="font-size: 12.5px;">&nbsp; &nbsp; &nbsp; &nbsp;以上是对jetty SpinLock的注释的具体翻译：</span></p><p><span style="font-size: 12.5px;"></span></p><p>&nbsp; &nbsp; &nbsp;This is a lock designed to protect VERY short sections of&nbsp;<span style="font-size: 12.5px;">critical code. &nbsp;Threads attempting to take the lock will spin &nbsp;</span><span style="font-size: 12.5px;">forever until the lock is available, thus it is important that&nbsp;</span><span style="font-size: 12.5px;">the code protected by this lock is extremely simple and non</span><span style="font-size: 12.5px;">&nbsp;blocking. The reason for this lock is that it prevents a thread&nbsp;</span><span style="font-size: 12.5px;">from giving up a CPU core when contending for the lock.</span></p><p>&nbsp;* try(SpinLock.Lock lock = spinlock.lock())</p><p>&nbsp;* {</p><p>&nbsp;* &nbsp; // something very quick and non blocking</p><p>&nbsp;* }</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;SpinLock&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;AtomicReference&lt;Thread&gt;&nbsp;_lock&nbsp;=&nbsp;new&nbsp;AtomicReference&lt;&gt;(null);
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;Lock&nbsp;_unlock&nbsp;=&nbsp;new&nbsp;Lock();
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Lock&nbsp;lock()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;thread&nbsp;=&nbsp;Thread.currentThread();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//通过CAS操作来获取锁
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!_lock.compareAndSet(null,thread))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;//不支持重入
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_lock.get()==thread)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalStateException("SpinLock&nbsp;is&nbsp;not&nbsp;reentrant");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_unlock;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;isLocked()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_lock.get()!=null;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;isLockedThread()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_lock.get()==Thread.currentThread();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;Lock&nbsp;implements&nbsp;AutoCloseable
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;//在try&nbsp;catch块中可以自动释放锁，不需要显示手动调用&nbsp;。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;close()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_lock.set(null);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p></p><p><span style="font-size: 12.5px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是我写的测试代码<br></span></p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;TestSpinLock&nbsp;implements&nbsp;Runnable&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;SpinLock&nbsp;spinLock=new&nbsp;SpinLock();
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;counter=0;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;incr(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try(SpinLock.Lock&nbsp;lock=spinLock.lock())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]args)&nbsp;throws&nbsp;InterruptedException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TestSpinLock&nbsp;testSpinLock=new&nbsp;TestSpinLock();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExecutorService&nbsp;executorService=&nbsp;Executors.newCachedThreadPool();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//提交三个任务，来同时计数
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executorService.submit(testSpinLock);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executorService.submit(testSpinLock);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executorService.submit(testSpinLock);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//等待任务完成
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executorService.shutdown();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executorService.awaitTermination(1000,&nbsp;TimeUnit.SECONDS);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(testSpinLock.counter);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;1000000;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incr();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p></p><p><span style="font-size: 12.5px;"></span>&nbsp; &nbsp; &nbsp; &nbsp;个人感觉jetty实现的这个SpinLock很精简，很容易理解。</p><p>&nbsp; &nbsp; &nbsp; 转发请注明来源：<a href="http://my.oschina.net/robinyao/blog/400712" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/400712</a></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_399164" href="http://my.oschina.net/robinyao/blog/399164">Maven依赖jar包冲突常见的解决方法</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-12 13:34:06</div>
	  <div class='catalog'>分类：java</div>
	  	  	  <div class='tags'>标签：maven,java,依赖冲突</div>	  	  	  </div>
      <div class='content'><p>&nbsp; &nbsp; 项目中，经常会遇到ClassNotFound，NoSuchMethod异常，第一反应往往是类路径不对，jar没有正确的引用。第一步判断jar是否加载，还是 加载的jar由于maven依赖管理存在传递依赖，造成依赖的jar版本号不对,相应的类找不到，或者是相应类版本不对，没有对应的方法。</p><p>一 &nbsp;造成jar 冲突的原因：如果项目中存在对同一jar不同版本依赖的时候，maven 2根据最近原则，默认引用最靠近项目版本的jar，maven 2.0.9会根据最先声明原则 来引用相应版本的jar;无论那种方式，都会出现jar包冲突。在这里提一下gradle依赖，会依赖最新版本的jar。</p><p>二 &nbsp;判断jar是否正确的被引用 有两种方法：</p><p>&nbsp; &nbsp; 1在项目启动时加上VM参数：-verbose:class</p><p>&nbsp; &nbsp; &nbsp; 项目启动的时候会把所有加载的jar都打印出来 类似如下的信息：</p><p>&nbsp; &nbsp; &nbsp; classpath加载的jar</p><pre class="brush:java;toolbar: true; auto-links: false;">-classpath&nbsp;/home/yao/tool/jdk1.8.0_25/jre/lib/jce.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/resources.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/rt.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/management-agent.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/jfxswt.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/plugin.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/javaws.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/charsets.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/jsse.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/deploy.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/jfr.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/ext/localedata.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/ext/nashorn.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/ext/jfxrt.jar:
/home/yao/tool/jdk1.8.0_25/jre/lib/ext/sunjce_provider.jar:
...............等等</pre><p>具体load的类</p><pre class="brush:java;toolbar: true; auto-links: false;">[Loaded&nbsp;java.lang.Object&nbsp;from&nbsp;/home/yao/tool/jdk1.8.0_25/jre/lib/rt.jar]
[Loaded&nbsp;java.io.Serializable&nbsp;from&nbsp;/home/yao/tool/jdk1.8.0_25/jre/lib/rt.jar]
[Loaded&nbsp;java.lang.Comparable&nbsp;from&nbsp;/home/yao/tool/jdk1.8.0_25/jre/lib/rt.jar]
[Loaded&nbsp;java.lang.CharSequence&nbsp;from&nbsp;/home/yao/tool/jdk1.8.0_25/jre/lib/rt.jar]
[Loaded&nbsp;java.lang.String&nbsp;from&nbsp;/home/yao/tool/jdk1.8.0_25/jre/lib/rt.jar]
[Loaded&nbsp;java.lang.reflect.AnnotatedElement&nbsp;from&nbsp;/home/yao/tool/jdk1.8.0_25/jre/lib/rt.jar]
[Loaded&nbsp;java.lang.reflect.GenericDeclaration&nbsp;from&nbsp;/home/yao/tool/jdk1.8.0_25/jre/lib/rt.jar]
[Loaded&nbsp;java.lang.reflect.Type&nbsp;from&nbsp;/home/yao/tool/jdk1.8.0_25/jre/lib/rt.jar]
[Loaded&nbsp;java.lang.Class&nbsp;from&nbsp;/home/yao/tool/jdk1.8.0_25/jre/lib/rt.jar]
..................等等</pre><p>我们可以通过上面的信息查找对应的jar是否正确的被依赖，具体类加载情况，同时可以看到版本号，确定是否由于依赖冲突造成的jar引用不正确；</p><p>&nbsp; &nbsp; 2 通过maven自带的工具：<span style="background-color: rgb(255, 0, 0);"><span style="display: none; line-height: 0px;">‍</span></span><span style="display: none; line-height: 0px;">‍</span>mvn dependency:tree</p><p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;具体后面可以加&nbsp;-Dverbose 参数 ，详细参数可以去自己搜，这里不详细介绍。</p><p>&nbsp; &nbsp; &nbsp; 比如分析如下POM</p><p>&nbsp; &nbsp; &nbsp; &nbsp;运行： mvn dependency:tree -Dverbose</p><pre class="brush:java;toolbar: true; auto-links: false;">&nbsp;&lt;dependencies&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dependency&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;poi&lt;/artifactId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;3.2-FINAL&lt;/version&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dependency&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dependency&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;commons-beanutils&lt;/groupId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;1.7.0&lt;/version&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dependency&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dependencies&gt;</pre><p>&nbsp; 输出结果:</p><pre class="brush:java;toolbar: true; auto-links: false;">[INFO]&nbsp;------------------------------------------------------------------------
[INFO]&nbsp;
[INFO]&nbsp;---&nbsp;maven-dependency-plugin:2.8:tree&nbsp;(default-cli)&nbsp;@&nbsp;Dependency&nbsp;---
[INFO]&nbsp;com.yao:Dependency:pom:1.0-SNAPSHOT
[INFO]&nbsp;+-&nbsp;org.apache.poi:poi:jar:3.2-FINAL:compile
[INFO]&nbsp;|&nbsp;&nbsp;+-&nbsp;commons-logging:commons-logging:jar:1.1:compile
[INFO]&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;\-&nbsp;log4j:log4j:jar:1.2.13:compile
[INFO]&nbsp;|&nbsp;&nbsp;\-&nbsp;(log4j:log4j:jar:1.2.13:compile&nbsp;-&nbsp;scope&nbsp;updated&nbsp;from&nbsp;runtime;&nbsp;omitted&nbsp;for&nbsp;duplicate)
[INFO]&nbsp;\-&nbsp;commons-beanutils:commons-beanutils:jar:1.7.0:compile
[INFO]&nbsp;&nbsp;&nbsp;&nbsp;\-&nbsp;(commons-logging:commons-logging:jar:1.0.3:compile&nbsp;-&nbsp;omitted&nbsp;for&nbsp;conflict&nbsp;with&nbsp;1.1)
[INFO]&nbsp;------------------------------------------------------------------------</pre><p>通过里面的信息可以看到 两个jar都commons-logging存在依赖，但是版本不同。里面的详细信息显示引用了 &nbsp;commons-logging:commons-logging:jar:1.1 &nbsp;去掉了commons-logging:commons-logging:jar:1.0.3 &nbsp;（omitted for duplicate）。</p><p>通过以上方法我们可以看到项目中引用jar版本号；接下来就是如何排除掉我们不想要版本的jar;</p><p>三 &nbsp;通过Idea intellij 中的Show Dependencies的工具去除重复的jar</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在Pom.xml文件上右击 选择 &nbsp;Diagrams &nbsp;-&gt; Show Dependencies 即可查看Pom的依赖图，通过图可以很容易的看到依赖冲突的jar,exculude掉不想要的版本jar即可。<br></p><p><img src="http://static.oschina.net/uploads/space/2015/0412/132521_rk2u_223302.jpg"></p><p><br></p><p><br></p><p>转发请注明来源 &nbsp;：<a href="http://my.oschina.net/robinyao/blog/399164" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/399164</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<br></p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_399060" href="http://my.oschina.net/robinyao/blog/399060">Netty实现服务端客户端长连接通讯及心跳检测</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-11 21:35:04</div>
	  <div class='catalog'>分类：netty</div>
	  	  	  <div class='tags'>标签：netty,java</div>	  	  	  </div>
      <div class='content'><p>&nbsp; &nbsp; &nbsp;&nbsp;通过netty实现服务端与客户端的长连接通讯，及心跳检测。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;基本思路：netty服务端通过一个Map保存所有连接上来的客户端SocketChannel,客户端的Id作为Map的key。每次服务器端如果要向某个客户端发送消息，只需根据ClientId取出对应的SocketChannel,往里面写入message即可。心跳检测通过IdleEvent事件，定时向服务端放送Ping消息，检测SocketChannel是否终断。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;环境JDK1.8 和netty5<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 以下是具体的代码实现和介绍：<br></p><p>1公共的Share部分(主要包含消息协议类型的定义)</p><p>&nbsp; &nbsp; &nbsp;设计消息类型：</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;enum&nbsp;&nbsp;MsgType&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;PING,ASK,REPLY,LOGIN
}</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;Message基类：</p><pre class="brush:java;toolbar: true; auto-links: false;">//必须实现序列,serialVersionUID&nbsp;一定要有,否者在netty消息序列化反序列化会有问题，接收不到消息！！！
public&nbsp;abstract&nbsp;class&nbsp;BaseMsg&nbsp;&nbsp;implements&nbsp;Serializable&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;long&nbsp;serialVersionUID&nbsp;=&nbsp;1L;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;MsgType&nbsp;type;
&nbsp;&nbsp;&nbsp;&nbsp;//必须唯一，否者会出现channel调用混乱
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;clientId;

&nbsp;&nbsp;&nbsp;&nbsp;//初始化客户端id
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;BaseMsg()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.clientId&nbsp;=&nbsp;Constants.getClientId();
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getClientId()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;clientId;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setClientId(String&nbsp;clientId)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.clientId&nbsp;=&nbsp;clientId;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;MsgType&nbsp;getType()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;type;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setType(MsgType&nbsp;type)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.type&nbsp;=&nbsp;type;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>常量设置：</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;Constants&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;String&nbsp;clientId;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;String&nbsp;getClientId()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;clientId;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;setClientId(String&nbsp;clientId)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constants.clientId&nbsp;=&nbsp;clientId;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>登录类型消息：</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;LoginMsg&nbsp;extends&nbsp;BaseMsg&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;userName;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;password;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;LoginMsg()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setType(MsgType.LOGIN);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getUserName()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;userName;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setUserName(String&nbsp;userName)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.userName&nbsp;=&nbsp;userName;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getPassword()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;password;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setPassword(String&nbsp;password)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.password&nbsp;=&nbsp;password;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>&nbsp;心跳检测Ping类型消息：</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;PingMsg&nbsp;extends&nbsp;BaseMsg&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;PingMsg()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setType(MsgType.PING);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>请求类型消息：</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;AskMsg&nbsp;extends&nbsp;BaseMsg&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;AskMsg()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setType(MsgType.ASK);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;AskParams&nbsp;params;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;AskParams&nbsp;getParams()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;params;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setParams(AskParams&nbsp;params)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.params&nbsp;=&nbsp;params;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
//请求类型参数
//必须实现序列化接口
public&nbsp;class&nbsp;AskParams&nbsp;implements&nbsp;Serializable&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;long&nbsp;serialVersionUID&nbsp;=&nbsp;1L;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;auth;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getAuth()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;auth;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setAuth(String&nbsp;auth)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.auth&nbsp;=&nbsp;auth;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>响应类型消息：</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;ReplyMsg&nbsp;extends&nbsp;BaseMsg&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ReplyMsg()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setType(MsgType.REPLY);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;ReplyBody&nbsp;body;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ReplyBody&nbsp;getBody()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;body;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setBody(ReplyBody&nbsp;body)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.body&nbsp;=&nbsp;body;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
//相应类型body对像
public&nbsp;class&nbsp;ReplyBody&nbsp;implements&nbsp;Serializable&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;long&nbsp;serialVersionUID&nbsp;=&nbsp;1L;
}
public&nbsp;class&nbsp;ReplyClientBody&nbsp;extends&nbsp;ReplyBody&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;clientInfo;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ReplyClientBody(String&nbsp;clientInfo)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.clientInfo&nbsp;=&nbsp;clientInfo;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getClientInfo()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;clientInfo;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setClientInfo(String&nbsp;clientInfo)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.clientInfo&nbsp;=&nbsp;clientInfo;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
public&nbsp;class&nbsp;ReplyServerBody&nbsp;extends&nbsp;ReplyBody&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;serverInfo;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ReplyServerBody(String&nbsp;serverInfo)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.serverInfo&nbsp;=&nbsp;serverInfo;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getServerInfo()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;serverInfo;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setServerInfo(String&nbsp;serverInfo)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.serverInfo&nbsp;=&nbsp;serverInfo;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>2 Server端：主要包含对<span style="font-family: Consolas, 'Bitstream Vera Sans Mono', 'Courier New', Courier, monospace; font-size: 12.8000001907349px; line-height: 13.75px; white-space: pre; background-color: rgb(255, 255, 255);">SocketChannel</span>引用的Map,ChannelHandler的实现和Bootstrap.<br></p><p>Map:<br></p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;NettyChannelMap&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Map&lt;String,SocketChannel&gt;&nbsp;map=new&nbsp;ConcurrentHashMap&lt;String,&nbsp;SocketChannel&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;add(String&nbsp;clientId,SocketChannel&nbsp;socketChannel){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(clientId,socketChannel);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Channel&nbsp;get(String&nbsp;clientId){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;map.get(clientId);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;remove(SocketChannel&nbsp;socketChannel){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Map.Entry&nbsp;entry:map.entrySet()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(entry.getValue()==socketChannel){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.remove(entry.getKey());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

}</pre><p>Handler<br></p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;NettyServerHandler&nbsp;extends&nbsp;SimpleChannelInboundHandler&lt;BaseMsg&gt;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;channelInactive(ChannelHandlerContext&nbsp;ctx)&nbsp;throws&nbsp;Exception&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//channel失效，从Map中移除
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NettyChannelMap.remove((SocketChannel)ctx.channel());
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;messageReceived(ChannelHandlerContext&nbsp;channelHandlerContext,&nbsp;BaseMsg&nbsp;baseMsg)&nbsp;throws&nbsp;Exception&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(MsgType.LOGIN.equals(baseMsg.getType())){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LoginMsg&nbsp;loginMsg=(LoginMsg)baseMsg;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if("robin".equals(loginMsg.getUserName())&amp;&amp;"yao".equals(loginMsg.getPassword())){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//登录成功,把channel存到服务端的map中
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NettyChannelMap.add(loginMsg.getClientId(),(SocketChannel)channelHandlerContext.channel());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("client"+loginMsg.getClientId()+"&nbsp;登录成功");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(NettyChannelMap.get(baseMsg.getClientId())==null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//说明未登录，或者连接断了，服务器向客户端发起登录请求，让客户端重新登录
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LoginMsg&nbsp;loginMsg=new&nbsp;LoginMsg();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channelHandlerContext.channel().writeAndFlush(loginMsg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(baseMsg.getType()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;PING:{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PingMsg&nbsp;pingMsg=(PingMsg)baseMsg;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PingMsg&nbsp;replyPing=new&nbsp;PingMsg();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NettyChannelMap.get(pingMsg.getClientId()).writeAndFlush(replyPing);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;ASK:{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//收到客户端的请求
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AskMsg&nbsp;askMsg=(AskMsg)baseMsg;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if("authToken".equals(askMsg.getParams().getAuth())){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReplyServerBody&nbsp;replyBody=new&nbsp;ReplyServerBody("server&nbsp;info&nbsp;$$$$&nbsp;!!!");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReplyMsg&nbsp;replyMsg=new&nbsp;ReplyMsg();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replyMsg.setBody(replyBody);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NettyChannelMap.get(askMsg.getClientId()).writeAndFlush(replyMsg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;REPLY:{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//收到客户端回复
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReplyMsg&nbsp;replyMsg=(ReplyMsg)baseMsg;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReplyClientBody&nbsp;clientBody=(ReplyClientBody)replyMsg.getBody();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("receive&nbsp;client&nbsp;msg:&nbsp;"+clientBody.getClientInfo());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReferenceCountUtil.release(baseMsg);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>ServerBootstrap:<br></p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;NettyServerBootstrap&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;port;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;SocketChannel&nbsp;socketChannel;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;NettyServerBootstrap(int&nbsp;port)&nbsp;throws&nbsp;InterruptedException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.port&nbsp;=&nbsp;port;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bind();
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;bind()&nbsp;throws&nbsp;InterruptedException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventLoopGroup&nbsp;boss=new&nbsp;NioEventLoopGroup();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventLoopGroup&nbsp;worker=new&nbsp;NioEventLoopGroup();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServerBootstrap&nbsp;bootstrap=new&nbsp;ServerBootstrap();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.group(boss,worker);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.channel(NioServerSocketChannel.class);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.option(ChannelOption.SO_BACKLOG,&nbsp;128);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//通过NoDelay禁用Nagle,使消息立即发出去，不用等待到一定的数据量才发出去
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.option(ChannelOption.TCP_NODELAY,&nbsp;true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//保持长连接状态
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.childOption(ChannelOption.SO_KEEPALIVE,&nbsp;true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.childHandler(new&nbsp;ChannelInitializer&lt;SocketChannel&gt;()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;initChannel(SocketChannel&nbsp;socketChannel)&nbsp;throws&nbsp;Exception&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChannelPipeline&nbsp;p&nbsp;=&nbsp;socketChannel.pipeline();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.addLast(new&nbsp;ObjectEncoder());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.addLast(new&nbsp;ObjectDecoder(ClassResolvers.cacheDisabled(null)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.addLast(new&nbsp;NettyServerHandler());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChannelFuture&nbsp;f=&nbsp;bootstrap.bind(port).sync();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f.isSuccess()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("server&nbsp;start---------------");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;[]args)&nbsp;throws&nbsp;InterruptedException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NettyServerBootstrap&nbsp;bootstrap=new&nbsp;NettyServerBootstrap(9999);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(true){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SocketChannel&nbsp;channel=(SocketChannel)NettyChannelMap.get("001");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(channel!=null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AskMsg&nbsp;askMsg=new&nbsp;AskMsg();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel.writeAndFlush(askMsg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimeUnit.SECONDS.sleep(5);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>3 Client端：包含发起登录，发送心跳，及对应消息处理<br></p><p>handler</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;NettyClientHandler&nbsp;extends&nbsp;SimpleChannelInboundHandler&lt;BaseMsg&gt;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//利用写空闲发送心跳检测消息
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;userEventTriggered(ChannelHandlerContext&nbsp;ctx,&nbsp;Object&nbsp;evt)&nbsp;throws&nbsp;Exception&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(evt&nbsp;instanceof&nbsp;IdleStateEvent)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IdleStateEvent&nbsp;e&nbsp;=&nbsp;(IdleStateEvent)&nbsp;evt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(e.state())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;WRITER_IDLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PingMsg&nbsp;pingMsg=new&nbsp;PingMsg();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.writeAndFlush(pingMsg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("send&nbsp;ping&nbsp;to&nbsp;server----------");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;messageReceived(ChannelHandlerContext&nbsp;channelHandlerContext,&nbsp;BaseMsg&nbsp;baseMsg)&nbsp;throws&nbsp;Exception&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MsgType&nbsp;msgType=baseMsg.getType();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(msgType){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;LOGIN:{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//向服务器发起登录
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LoginMsg&nbsp;loginMsg=new&nbsp;LoginMsg();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loginMsg.setPassword("yao");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loginMsg.setUserName("robin");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channelHandlerContext.writeAndFlush(loginMsg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;PING:{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("receive&nbsp;ping&nbsp;from&nbsp;server----------");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;ASK:{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReplyClientBody&nbsp;replyClientBody=new&nbsp;ReplyClientBody("client&nbsp;info&nbsp;****&nbsp;!!!");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReplyMsg&nbsp;replyMsg=new&nbsp;ReplyMsg();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replyMsg.setBody(replyClientBody);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channelHandlerContext.writeAndFlush(replyMsg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;REPLY:{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReplyMsg&nbsp;replyMsg=(ReplyMsg)baseMsg;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReplyServerBody&nbsp;replyServerBody=(ReplyServerBody)replyMsg.getBody();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("receive&nbsp;client&nbsp;msg:&nbsp;"+replyServerBody.getServerInfo());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReferenceCountUtil.release(msgType);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>bootstrap</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;NettyClientBootstrap&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;port;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;host;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;SocketChannel&nbsp;socketChannel;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;EventExecutorGroup&nbsp;group&nbsp;=&nbsp;new&nbsp;DefaultEventExecutorGroup(20);
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;NettyClientBootstrap(int&nbsp;port,&nbsp;String&nbsp;host)&nbsp;throws&nbsp;InterruptedException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.port&nbsp;=&nbsp;port;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.host&nbsp;=&nbsp;host;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;start()&nbsp;throws&nbsp;InterruptedException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventLoopGroup&nbsp;eventLoopGroup=new&nbsp;NioEventLoopGroup();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bootstrap&nbsp;bootstrap=new&nbsp;Bootstrap();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.channel(NioSocketChannel.class);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.option(ChannelOption.SO_KEEPALIVE,true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.group(eventLoopGroup);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.remoteAddress(host,port);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.handler(new&nbsp;ChannelInitializer&lt;SocketChannel&gt;()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;initChannel(SocketChannel&nbsp;socketChannel)&nbsp;throws&nbsp;Exception&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socketChannel.pipeline().addLast(new&nbsp;IdleStateHandler(20,10,0));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socketChannel.pipeline().addLast(new&nbsp;ObjectEncoder());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socketChannel.pipeline().addLast(new&nbsp;ObjectDecoder(ClassResolvers.cacheDisabled(null)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socketChannel.pipeline().addLast(new&nbsp;NettyClientHandler());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChannelFuture&nbsp;future&nbsp;=bootstrap.connect(host,port).sync();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(future.isSuccess())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socketChannel&nbsp;=&nbsp;(SocketChannel)future.channel();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("connect&nbsp;server&nbsp;&nbsp;成功---------");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]args)&nbsp;throws&nbsp;InterruptedException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constants.setClientId("001");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NettyClientBootstrap&nbsp;bootstrap=new&nbsp;NettyClientBootstrap(9999,"localhost");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LoginMsg&nbsp;loginMsg=new&nbsp;LoginMsg();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loginMsg.setPassword("yao");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loginMsg.setUserName("robin");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.socketChannel.writeAndFlush(loginMsg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(true){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimeUnit.SECONDS.sleep(3);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AskMsg&nbsp;askMsg=new&nbsp;AskMsg();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AskParams&nbsp;askParams=new&nbsp;AskParams();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;askParams.setAuth("authToken");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;askMsg.setParams(askParams);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bootstrap.socketChannel.writeAndFlush(askMsg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>具体的例子和相应pom.xml 见&nbsp;<a href="https://github.com/WangErXiao/ServerClient" target="_self" rel="nofollow">https://github.com/WangErXiao/ServerClient</a></p><p>转发请注明来源：<a href="http://my.oschina.net/robinyao/blog/399060" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/399060</a></p></div>
	  	  <div class='commentList'>
		<h3>评论列表</h3>
	    	    <div class='comment'>
		  <div class='author'>空北</div>
		  <div class='date'>2015-04-13 09:24:06</div>
		  <div class='content'>netty不是提供了原生的ChannelGroups来做map的事情吗？</div>
		</div>
			    <div class='comment'>
		  <div class='author'>robin-yao</div>
		  <div class='date'>2015-04-13 10:30:36</div>
		  <div class='content'><div class='ref'><h4>引用来自“空北”的评论</h4>netty不是提供了原生的ChannelGroups来做map的事情吗？</div>ChannelGroups可以做的</div>
		</div>
			    <div class='comment'>
		  <div class='author'>wangyunzhong</div>
		  <div class='date'>2015-04-13 16:00:27</div>
		  <div class='content'>netty提供了连接断开的回调：<br/>@Override<br/>&nbsp;&nbsp;public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws Exception<br/>@Override<br/>&nbsp;&nbsp;public void channelDisconnected(ChannelHandlerContext ctx,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChannelStateEvent e) throws Exception<br/>为什么自己做心跳。</div>
		</div>
			    <div class='comment'>
		  <div class='author'>robin-yao</div>
		  <div class='date'>2015-04-13 16:21:04</div>
		  <div class='content'><div class='ref'><h4>引用来自“wangyunzhong”的评论</h4>netty提供了连接断开的回调：<br/>@Override<br/>&nbsp;&nbsp;public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws Exception<br/>@Override<br/>&nbsp;&nbsp;public void channelDisconnected(ChannelHandlerContext ctx,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChannelStateEvent e) throws Exception<br/>为什么自己做心跳。</div>主要是一些业务 需要通过收到的消息来处理，如果仅仅通过 channelConnected 拿不到消息。我们可以在Ping中自定义自己需要的信息，在messageReceive中实现自己的业务逻辑。</div>
		</div>
			    <div class='comment'>
		  <div class='author'>蜀山下的鱼</div>
		  <div class='date'>2015-04-13 20:38:59</div>
		  <div class='content'><div class='ref'><div class='ref'><h4>引用来自“wangyunzhong”的评论</h4>netty提供了连接断开的回调：<br/>@Override<br/>&nbsp;&nbsp;public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws Exception<br/>@Override<br/>&nbsp;&nbsp;public void channelDisconnected(ChannelHandlerContext ctx,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChannelStateEvent e) throws Exception<br/>为什么自己做心跳。</div><h4>引用来自“robin-yao”的评论</h4>主要是一些业务 需要通过收到的消息来处理，如果仅仅通过 channelConnected 拿不到消息。我们可以在Ping中自定义自己需要的信息，在messageReceive中实现自己的业务逻辑。</div>没明白？  保持心跳跟业务有关系吗？  </div>
		</div>
			    <div class='comment'>
		  <div class='author'>robin-yao</div>
		  <div class='date'>2015-04-13 20:46:20</div>
		  <div class='content'><div class='ref'><div class='ref'><div class='ref'><h4>引用来自“wangyunzhong”的评论</h4>netty提供了连接断开的回调：<br/>@Override<br/>&nbsp;&nbsp;public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws Exception<br/>@Override<br/>&nbsp;&nbsp;public void channelDisconnected(ChannelHandlerContext ctx,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChannelStateEvent e) throws Exception<br/>为什么自己做心跳。</div><h4>引用来自“robin-yao”的评论</h4>主要是一些业务 需要通过收到的消息来处理，如果仅仅通过 channelConnected 拿不到消息。我们可以在Ping中自定义自己需要的信息，在messageReceive中实现自己的业务逻辑。</div><h4>引用来自“蜀山下的鱼”的评论</h4>没明白？  保持心跳跟业务有关系吗？  </div>比如我们想记录断掉客户端的Id,Ping消息可以把客户的Id带过来了。我们可以在ping上添加我们需要的信息</div>
		</div>
			    <div class='comment'>
		  <div class='author'>mcloud</div>
		  <div class='date'>2015-04-13 21:23:35</div>
		  <div class='content'><div class=ref><h4>引用来自“wangyunzhong”的评论</h4><p>netty提供了连接断开的回调：<br/>@Override<br/>&nbsp;&nbsp;public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws Exception<br/>@Override<br/>&nbsp;&nbsp;public void channelDisconnected(ChannelHandlerContext ctx,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChannelStateEvent e) throws Exception<br/>为什么自己做心跳。</p></div>tcp非正常断开太正常了，否则一大堆死链，特别在移动网络场景下 </div>
		</div>
			    <div class='comment'>
		  <div class='author'>云颖</div>
		  <div class='date'>2015-04-14 11:27:42</div>
		  <div class='content'>mark<br/> </div>
		</div>
			    <div class='comment'>
		  <div class='author'>zhustanley</div>
		  <div class='date'>2015-04-15 09:33:01</div>
		  <div class='content'>remoteaddr就行了。不用额外的clientId</div>
		</div>
			    <div class='comment'>
		  <div class='author'>zhustanley</div>
		  <div class='date'>2015-04-15 09:48:58</div>
		  <div class='content'>这个效率太差！！！<br/>    public static void remove(SocketChannel socketChannel){         for (Map.Entry entry:map.entrySet()){             if (entry.getValue()==socketChannel){                 map.remove(entry.getKey());             }         }     } <br/></div>
		</div>
			    <div class='comment'>
		  <div class='author'>鑫鑫哥哥呀</div>
		  <div class='date'>2015-04-20 16:02:06</div>
		  <div class='content'>mark </div>
		</div>
			    <div class='comment'>
		  <div class='author'>这个男人来自地球</div>
		  <div class='date'>2015-04-21 21:15:19</div>
		  <div class='content'><div class='ref'><h4>引用来自“zhustanley”的评论</h4>这个效率太差！！！<br/>    public static void remove(SocketChannel socketChannel){         for (Map.Entry entry:map.entrySet()){             if (entry.getValue()==socketChannel){                 map.remove(entry.getKey());             }         }     } <br/></div>有什么改进的想法？</div>
		</div>
			    <div class='comment'>
		  <div class='author'>Linux一叶</div>
		  <div class='date'>2015-04-22 13:36:31</div>
		  <div class='content'>你自己测试了吗？？？？？？？？？？？</div>
		</div>
			    <div class='comment'>
		  <div class='author'>Linux一叶</div>
		  <div class='date'>2015-04-22 13:37:01</div>
		  <div class='content'>给你提交个大量bug   换是给你修改？？</div>
		</div>
			    <div class='comment'>
		  <div class='author'>robin-yao</div>
		  <div class='date'>2015-04-22 16:54:05</div>
		  <div class='content'><div class=ref><h4>引用来自“夜域诡士”的评论</h4><p>给你提交个大量bug   换是给你修改？？</p></div>??啥Bug</div>
		</div>
			    <div class='comment'>
		  <div class='author'>Linux一叶</div>
		  <div class='date'>2015-04-22 21:37:54</div>
		  <div class='content'><div class=ref><h4>引用来自“robin-yao”的评论</h4><p><div class=ref><h4>引用来自“夜域诡士”的评论</h4><p>给你提交个大量bug   换是给你修改？？</p></div>??啥Bug</p></div>时间长了，出现一堆bug</div>
		</div>
			    <div class='comment'>
		  <div class='author'>Linux一叶</div>
		  <div class='date'>2015-04-22 21:38:54</div>
		  <div class='content'><div class=ref><h4>引用来自“robin-yao”的评论</h4><p><div class=ref><h4>引用来自“夜域诡士”的评论</h4><p>给你提交个大量bug   换是给你修改？？</p></div>??啥Bug</p></div>还总是报找不到class</div>
		</div>
			  </div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_398808" href="http://my.oschina.net/robinyao/blog/398808">利用Redis BitMap 统计用户活跃指标</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-04-11 00:16:56</div>
	  <div class='catalog'>分类：redis</div>
	  	  	  <div class='tags'>标签：redis,java,jedis,bitmap</div>	  	  	  </div>
      <div class='content'><p>&nbsp; &nbsp; bitMap原理 :</p><p>&nbsp; &nbsp; 如下： index 从 0 到 9 ，依次对应到一个bit位上，如果index 代表用户id,bit位上的0 1分表 代表用户是否登录；</p><table><tbody><tr><td style="word-break: break-all;">1</td><td style="word-break: break-all;">0</td><td style="word-break: break-all;">1</td><td style="word-break: break-all;">1</td><td style="word-break: break-all;">0</td><td style="word-break: break-all;">1</td><td style="word-break: break-all;">1</td><td style="word-break: break-all;">0</td><td style="word-break: break-all;">1</td><td style="word-break: break-all;">1</td></tr></tbody></table><p><br></p><table><tbody><tr><td style="word-break: break-all;">0</td><td style="word-break: break-all;">1</td><td style="word-break: break-all;">2</td><td style="word-break: break-all;">3</td><td style="word-break: break-all;">4</td><td style="word-break: break-all;">5</td><td style="word-break: break-all;">6</td><td style="word-break: break-all;">7</td><td style="word-break: break-all;">8</td><td style="word-break: break-all;">9</td></tr></tbody></table><p>&nbsp; &nbsp;</p><p>&nbsp; &nbsp;redis数据结构中 string 类型，包含了对bitmap的实现;在redis-cli中，可以通过setbit getbit 来对bit进行操作；本文通过jedis来对redis进行操作；&nbsp;</p><p>BitSet工具类：实现对通过jedis.get(key)取出的byte[]值与BitSet的转换</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;BitSetUtils&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;将BitSet对象转化为ByteArray
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;bitSet
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;byte[]&nbsp;bitSet2ByteArray(BitSet&nbsp;bitSet)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]&nbsp;bytes&nbsp;=&nbsp;new&nbsp;byte[bitSet.size()&nbsp;/&nbsp;8];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;bitSet.size();&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;index&nbsp;=&nbsp;i&nbsp;/&nbsp;8;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;offset&nbsp;=&nbsp;7&nbsp;-&nbsp;i&nbsp;%&nbsp;8;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes[index]&nbsp;|=&nbsp;(bitSet.get(i)&nbsp;?&nbsp;1&nbsp;:&nbsp;0)&nbsp;&lt;&lt;&nbsp;offset;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;bytes;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;bytes
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;BitSet&nbsp;byteArray2BitSet(byte[]&nbsp;bytes)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitSet&nbsp;bitSet&nbsp;=&nbsp;new&nbsp;BitSet(bytes.length&nbsp;*&nbsp;8);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;index&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;bytes.length;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;7;&nbsp;j&nbsp;&gt;=&nbsp;0;&nbsp;j--)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bitSet.set(index++,&nbsp;(bytes[i]&nbsp;&amp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;j))&nbsp;&gt;&gt;&nbsp;j&nbsp;==&nbsp;1&nbsp;?&nbsp;true
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;bitSet;
&nbsp;&nbsp;&nbsp;&nbsp;}

}</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;具体对java中BitSet操作，见<a href="http://my.oschina.net/cloudcoder/blog/294810" target="_self" rel="nofollow">http://my.oschina.net/cloudcoder/blog/294810</a> ，该篇对bitSet用法介绍很详细；</p><p>redis工具类：</p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;class&nbsp;RedisUtil&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initPool();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;volatile&nbsp;JedisPool&nbsp;jedisPool;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;ResourceBundle&nbsp;resourceBundle;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Jedis&nbsp;getResource()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;jedisPool.getResource();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;returnResource(Jedis&nbsp;jedis)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jedisPool.returnResource(jedis);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;initPool()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(jedisPool&nbsp;!=&nbsp;null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loadProperties();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;host&nbsp;=&nbsp;resourceBundle.getString("redis.host");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;passwd=&nbsp;resourceBundle.getString("redis.passwd");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;port&nbsp;=&nbsp;Integer.parseInt(resourceBundle.getString("redis.port"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JedisPoolConfig&nbsp;config&nbsp;=&nbsp;config();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jedisPool&nbsp;=&nbsp;new&nbsp;JedisPool(config,host,port,60,passwd);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;void&nbsp;loadProperties()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resourceBundle&nbsp;=&nbsp;ResourceBundle.getBundle("config/redis-config");
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;JedisPoolConfig&nbsp;config()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JedisPoolConfig&nbsp;config&nbsp;=&nbsp;new&nbsp;JedisPoolConfig();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;config;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]args){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jedis&nbsp;jedis=&nbsp;RedisUtil.getResource();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RedisUtil.returnResource(jedis);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><span style="font-size: 12.5px;">&nbsp;1 统计系统中某天用户登录的情况：以当天日期做为key ,比如 ‘20150410’ ，对应的 bitMap 的 index 用userId来标示，UserId这里用 &nbsp;long 型表示，如果id不是以0开头，可以加上相应的偏移量就OK了；如果该天用户登录，调用activeUser方法，来更改bitMap相应index上的标示；</span><br></p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;void&nbsp;activeUser(long&nbsp;userId,&nbsp;String&nbsp;dateKey)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;Jedis&nbsp;jedis=&nbsp;RedisUtil.getResource();
&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jedis.setbit(dateKey,userId,true);
&nbsp;&nbsp;&nbsp;&nbsp;}finally&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RedisUtil.returnResource(jedis);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><span style="font-size: 12.5px;"></span>如果我们想统计该天用户登录的数量，及登录的用户id,可以通过如下方法实现：</p><pre class="brush:java;toolbar: true; auto-links: false;">//该天用户总数
public&nbsp;long&nbsp;totalCount(String&nbsp;dateKey)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;Jedis&nbsp;jedis=&nbsp;RedisUtil.getResource();
&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;jedis.bitcount(dateKey);
&nbsp;&nbsp;&nbsp;&nbsp;}finally&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RedisUtil.returnResource(jedis);
&nbsp;&nbsp;&nbsp;&nbsp;}
}

//该天登录所有的用户id
public&nbsp;List&lt;Long&gt;&nbsp;activeUserIds(String&nbsp;&nbsp;dateKey)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;Jedis&nbsp;jedis=&nbsp;RedisUtil.getResource();
&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(jedis.get(key)==null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitSet&nbsp;set=&nbsp;BitSetUtils.byteArray2BitSet(jedis.get(key).getBytes());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Long&gt;list=new&nbsp;ArrayList&lt;Long&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(long&nbsp;i=0;i&lt;set.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(set.get(i)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;list;
&nbsp;&nbsp;&nbsp;&nbsp;}finally&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RedisUtil.returnResource(jedis);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>&nbsp; &nbsp;2 如果我们想统计n天，连续登录的用户数，及UserId:<br></p><pre class="brush:java;toolbar: true; auto-links: false;">public&nbsp;List&lt;Long&gt;&nbsp;continueActiveUserCount(String...&nbsp;dateKeys)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;Jedis&nbsp;jedis=&nbsp;RedisUtil.getResource();
&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitSet&nbsp;all&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(String&nbsp;key:dateKeys){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(jedis.get(key)==null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitSet&nbsp;set=&nbsp;BitSetUtils.byteArray2BitSet(jedis.get(key).getBytes());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(all==null){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all=set;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(set.size());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all.and(set);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Long&gt;list=new&nbsp;ArrayList&lt;Long&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(long&nbsp;i=0;i&lt;all.size();i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(all.get(i)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;list;
&nbsp;&nbsp;&nbsp;&nbsp;}finally&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RedisUtil.returnResource(jedis);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>&nbsp;</p><p><br></p><p>转载请注明来源：<a href="http://my.oschina.net/robinyao/blog/398808" target="_self" rel="nofollow">http://my.oschina.net/robinyao/blog/398808</a></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p></div>
	  	  <div class='commentList'>
		<h3>评论列表</h3>
	    	    <div class='comment'>
		  <div class='author'>dubingl</div>
		  <div class='date'>2015-04-16 07:37:56</div>
		  <div class='content'>好思路 </div>
		</div>
			  </div>
	      </div>
      </div>
</body>
</html>
    